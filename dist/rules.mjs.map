{"version":3,"sources":["../src/rules.ts","../src/conf/lexer_rules.ts","../src/conf/lsp_rules.ts","../src/conf/parser_rules.ts","../src/rules/Expr.ts","../src/rules/Stmt.ts","../src/rules/Type.ts"],"sourcesContent":["// rules.ts — Parser rules and grammar definitions for the Kemet programming language.\n//\n// repo   : https://github.com/kemet-lang/rules\n// author : https://github.com/maysara-elshewehy\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import * as syntax          from '@je-es/syntax';\n    import { lexerRules }       from './conf/lexer_rules';\n    import { lspConfig }        from './conf/lsp_rules';\n    import { parserRules, parserSettings } from './conf/parser_rules';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ INIT ════════════════════════════════════════╗\n\n    export const KemetSyntax = syntax.create({\n            name     : 'Kemet',\n            version  : '0.0.1',\n            lexer    : lexerRules,\n            parser   : parserRules,\n            lsp      : lspConfig,\n            settings : parserSettings\n        } as syntax.SyntaxConfig\n    );\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// lexer_rules.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import * as LexerLib from '@je-es/lexer';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ INIT ════════════════════════════════════════╗\n\n    export const lexerRules : LexerLib.Rules = {\n        // ═══ Whitespace ═══\n        ws              : /\\s+/,\n\n        // ═══ Comments ═══\n        document        : { match: /\\/\\/\\/[!/]?.*/, value: (text: string) => text.slice(3).trim() },\n        comment         : { match: /\\/\\/[!/]?.*/,   value: (text: string) => text.slice(2).trim() },\n\n        // ═══ Literals ═══\n        flt             : /[0-9]+\\.[0-9]+(?:[eE][+-]?[0-9]+)?/,\n        bin             : /0b[01]+/,\n        oct             : /0o[0-7]+/,\n        hex             : /0x[0-9a-fA-F]+/,\n        dec             : /[0-9]+/,\n        slice           : { match: /\"(?:[^\"\\\\]|\\\\.)*\"/, value: (text: string) => text.slice(1, -1) },\n        char            : { match: /'(?:[^'\\\\]|\\\\.)*'/, value: (text: string) => text.slice(1, -1) },\n\n        // ═══ Keywords ═══\n        true            : 'true',\n        false           : 'false',\n        null            : 'null',\n        null_t          : 'null_t',\n        und             : 'und',\n        und_t           : 'und_t',\n        noreturn        : 'noreturn',\n        unreachable     : 'unreachable',\n\n        test            : 'test',\n        new             : 'new',\n        try             : 'try',\n        catch           : 'catch',\n        use             : 'use',\n        as              : 'as',\n        from            : 'from',\n        pub             : 'pub',\n        def             : 'def',\n        let             : 'let',\n        fn              : 'fn',\n\n        mut             : 'mut',\n        inline          : 'inline',\n        static          : 'static',\n        struct          : 'struct',\n        enum            : 'enum',\n        errset          : 'errset',\n\n        typeof          : 'typeof',\n        sizeof          : 'sizeof',\n\n        if              : 'if',\n        else            : 'else',\n\n        while           : 'while',\n        for             : 'for',\n        do              : 'do',\n\n\n        return          : 'return',\n        defer           : 'defer',\n        throw           : 'throw',\n\n        break           : 'break',\n        continue        : 'continue',\n\n        match          : 'match',\n        default         : 'default',\n\n        comptime        : 'comptime',\n\n\n        // ═══ Types ═══\n        i_type          : { match: /i[0-9]+/ },\n        u_type          : { match: /u[0-9]+/ },\n        f_type          : ['f16', 'f32', 'f64', 'f80', 'f128'],\n        cint            : 'cint',\n        cflt            : 'cflt',\n        isize           : 'isize',\n        usize           : 'usize',\n        bool            : 'bool',\n        void            : 'void',\n        type            : 'type',\n        any             : 'any',\n        err             : 'err',\n\n        // ═══ Operators ═══\n        '->'            : '->',     // Function Return operator\n        '=>'            : '=>',     // Match case operator\n        '.*'            : '.*',     // Dereference operator\n        '??'            : '??',     // Null coalescing operator\n        '..='           : '..=',    // Range operator (Inclusive)\n        '..'            : '..',     // Range operator (Exclusive)\n        '@'             : '@',      // Builtin operator\n        '=='            : '==',\n        '!='            : '!=',\n        '<='            : '<=',\n        '>='            : '>=',\n        '+='            : '+=',\n        '-='            : '-=',\n        '*='            : '*=',\n        '/='            : '/=',\n        '%='            : '%=',\n        '**'            : '**',\n        '++'            : '++',\n        '--'            : '--',\n        '<<'            : '<<',\n        '>>'            : '>>',\n        'and'           : 'and',\n        'or'            : 'or',\n        '<'             : '<',\n        '>'             : '>',\n        '|'             : '|',\n        '^'             : '^',\n        '&'             : '&',\n        '='             : '=',\n        '+'             : '+',\n        '-'             : '-',\n        '*'             : '*',\n        '/'             : '/',\n        '%'             : '%',\n        '?'             : '?',\n        '!'             : '!',\n        '~'             : '~',\n        ':'             : ':',\n        ';'             : ';',\n        ','             : ',',\n        '.'             : '.',\n        '('             : '(',\n        ')'             : ')',\n        '{'             : '{',\n        '}'             : '}',\n        '['             : '[',\n        ']'             : ']',\n\n        // ═══ Identifier ═══\n        ident           : /[a-zA-Z_][a-zA-Z0-9_]*/,\n    };\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// lsp_rules.ts — LSP configuration for Kemet language\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import type { LSPConfig, KeywordDoc } from '@je-es/syntax';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ INIT ════════════════════════════════════════╗\n\n    export const lspConfig: LSPConfig = {\n        // ═══ Keywords ═══\n        keywords: {\n            declarations: [\n                'let', 'fn', 'def', 'use', 'pub', 'test'\n            ],\n\n            types: [\n                // Signed integers\n                'i8', 'i16', 'i32', 'i64', 'i128', 'i256', 'isize',\n                // Unsigned integers\n                'u8', 'u16', 'u32', 'u64', 'u128', 'u256', 'usize',\n                // Floating point\n                'f16', 'f32', 'f64', 'f80', 'f128',\n                // C interop\n                'cint', 'cflt',\n                // Basic types\n                'bool', 'void', 'type', 'any', 'err',\n                // Type constructors\n                'struct', 'enum', 'errset',\n                // Special types\n                'null_t', 'und_t',\n                // Type aliases\n                'char', 'cpoint'\n            ],\n\n            controlFlow: [\n                'if', 'else', 'match', 'default',\n                'for', 'while', 'do',\n                'break', 'continue', 'return', 'defer', 'throw'\n            ],\n\n            modifiers: [\n                'mut', 'pub', 'static', 'inline', 'comptime'\n            ],\n\n            operators: [\n                'as', 'typeof', 'sizeof', 'try', 'catch',\n                'and', 'or', 'new', 'from'\n            ],\n\n            literals: [\n                'true', 'false', 'null', 'und'\n            ],\n\n            builtins: [\n                '@print', '@i', '@assert', 'self', 'selferr'\n            ]\n        },\n\n        // ═══ Keyword Documentation ═══\n        keywordDocs: {\n            // Declarations\n            'let': {\n                signature: '[pub|static] [comptime] let [mut] name[: type] [= value]',\n                description: 'Declare a variable with optional type annotation and initializer. Variables are immutable by default unless marked with `mut`.',\n                example: 'let mut counter: i32 = 0;\\nlet name = \"Alice\"; // type inferred'\n            },\n\n            'fn': {\n                signature: '[pub|static] [comptime] [inline] fn name(params) [-> [ErrorType!]ReturnType] body',\n                description: 'Declare a function. Functions can have error types, return types, or both. If no return type specified, defaults to void.',\n                example: 'pub fn divide(a: i32, b: i32) -> err!i32 {\\n  if (b == 0) { throw err; }\\n  return a / b;\\n}'\n            },\n\n            'def': {\n                signature: '[pub|static] def Name = type',\n                description: 'Define a type alias or named type',\n                example: 'pub def Point = struct { x: i32; y: i32 };\\ndef MyInt = i32;'\n            },\n\n            'use': {\n                signature: 'use target [as alias] from \"path\" | use * as alias from \"path\"',\n                description: 'Import symbols from another module. Can import specific symbols, or use wildcard (*) to import all public symbols with an alias.',\n                example: 'use Point from \"./types.k\";\\nuse * as utils from \"./utils.k\";\\nutils.print(\"hello\");'\n            },\n\n            'pub': {\n                signature: 'pub',\n                description: 'Make a declaration public (exported from module)',\n                example: 'pub let API_KEY = \"...\";\\npub fn process() {}'\n            },\n\n            'static': {\n                signature: 'static',\n                description: 'Declare a static member (available on type, not instance). Static methods can only access other static members.',\n                example: 'def Point = struct {\\n  static count: i32 = 0;\\n  static fn getCount() -> i32 { return self.count; }\\n}'\n            },\n\n            'test': {\n                signature: 'test [\"name\"] { }',\n                description: 'Define a test block with optional name',\n                example: 'test \"addition works\" {\\n  @assert(1 + 1 == 2);\\n}'\n            },\n\n            // Type keywords\n            'struct': {\n                signature: 'struct { fields..., methods... }',\n                description: 'Define a structure type with fields and optional methods. Fields can have default values.',\n                example: 'struct {\\n  pub x: i32 = 0;\\n  pub y: i32 = 0;\\n  pub fn distance(self) -> f32 { ... }\\n}'\n            },\n\n            'enum': {\n                signature: 'enum { Variant1[:Type1], Variant2, ... }',\n                description: 'Define an enumeration type with optional associated types for each variant',\n                example: 'enum { Some: i32, None }\\nenum { Red, Green, Blue }'\n            },\n\n            'errset': {\n                signature: 'errset { Error1, Error2, ... }',\n                description: 'Define an error set type containing named error variants',\n                example: 'errset { FileNotFound, AccessDenied, InvalidInput }'\n            },\n\n            // Primitive types - Integer types\n            'i8': {\n                signature: 'i8',\n                description: 'Signed 8-bit integer (-128 to 127)'\n            },\n\n            'i16': {\n                signature: 'i16',\n                description: 'Signed 16-bit integer (-32,768 to 32,767)'\n            },\n\n            'i32': {\n                signature: 'i32',\n                description: 'Signed 32-bit integer (-2,147,483,648 to 2,147,483,647)'\n            },\n\n            'i64': {\n                signature: 'i64',\n                description: 'Signed 64-bit integer'\n            },\n\n            'i128': {\n                signature: 'i128',\n                description: 'Signed 128-bit integer'\n            },\n\n            'i256': {\n                signature: 'i256',\n                description: 'Signed 256-bit integer'\n            },\n\n            'isize': {\n                signature: 'isize',\n                description: 'Signed pointer-sized integer (platform dependent, typically 64-bit)'\n            },\n\n            'u8': {\n                signature: 'u8',\n                description: 'Unsigned 8-bit integer (0 to 255)'\n            },\n\n            'u16': {\n                signature: 'u16',\n                description: 'Unsigned 16-bit integer (0 to 65,535)'\n            },\n\n            'u32': {\n                signature: 'u32',\n                description: 'Unsigned 32-bit integer (0 to 4,294,967,295)'\n            },\n\n            'u64': {\n                signature: 'u64',\n                description: 'Unsigned 64-bit integer'\n            },\n\n            'u128': {\n                signature: 'u128',\n                description: 'Unsigned 128-bit integer'\n            },\n\n            'u256': {\n                signature: 'u256',\n                description: 'Unsigned 256-bit integer'\n            },\n\n            'usize': {\n                signature: 'usize',\n                description: 'Unsigned pointer-sized integer (platform dependent, typically 64-bit)'\n            },\n\n            // Floating point types\n            'f16': {\n                signature: 'f16',\n                description: 'Half-precision 16-bit floating point'\n            },\n\n            'f32': {\n                signature: 'f32',\n                description: 'Single-precision 32-bit floating point'\n            },\n\n            'f64': {\n                signature: 'f64',\n                description: 'Double-precision 64-bit floating point'\n            },\n\n            'f80': {\n                signature: 'f80',\n                description: 'Extended-precision 80-bit floating point'\n            },\n\n            'f128': {\n                signature: 'f128',\n                description: 'Quadruple-precision 128-bit floating point'\n            },\n\n            // C interop types\n            'cint': {\n                signature: 'cint',\n                description: 'Compile-time integer type (for compile-time computation and FFI compatibility)'\n            },\n\n            'cflt': {\n                signature: 'cflt',\n                description: 'Compile-time float type (for compile-time computation and FFI compatibility)'\n            },\n\n            // Other primitive types\n            'bool': {\n                signature: 'bool',\n                description: 'Boolean type (true or false)'\n            },\n\n            'void': {\n                signature: 'void',\n                description: 'Void type (represents no value)'\n            },\n\n            'type': {\n                signature: 'type',\n                description: 'Type of types (metatype)'\n            },\n\n            'any': {\n                signature: 'any',\n                description: 'Any type (accepts any value, runtime type checking)'\n            },\n\n            'err': {\n                signature: 'err',\n                description: 'Generic error type. Can be used as error union type (err!) or variable type to hold any error.'\n            },\n\n            'null_t': {\n                signature: 'null_t',\n                description: 'Type of null value'\n            },\n\n            'und_t': {\n                signature: 'und_t',\n                description: 'Type of undefined value'\n            },\n\n            // Type Aliases\n            'char': {\n                signature: 'char (u8)',\n                description: 'ASCII character type (alias for u8). Character literals with ASCII values infer to this type.'\n            },\n\n            'cpoint': {\n                signature: 'cpoint (u21)',\n                description: 'Unicode code point type (alias for u21). Character literals with non-ASCII values infer to this type.'\n            },\n\n            // Control flow\n            'if': {\n                signature: 'if condition stmt [else stmt]',\n                description: 'Conditional expression/statement. Condition must be a boolean expression.',\n                example: 'if (x > 0) {\\n  @print(\"positive\");\\n} else {\\n  @print(\"non-positive\");\\n}'\n            },\n\n            'else': {\n                signature: 'else',\n                description: 'Alternative branch for if statement'\n            },\n\n            'match': {\n                signature: 'match expr { value => stmt ... [default => stmt] }',\n                description: 'Match statement for pattern matching. Must be exhaustive for enum types or include default case.',\n                example: 'match (value) {\\n  1 => { @print(\"one\"); }\\n  2 => { @print(\"two\"); }\\n  default: { @print(\"other\"); }\\n}'\n            },\n\n            'case': {\n                signature: 'value => stmt',\n                description: 'Case branch in match statement',\n                example: '42 => { @print(\"found\"); }'\n            },\n\n            'default': {\n                signature: 'default: stmt',\n                description: 'Default case in match statement (fallback when no other case matches)'\n            },\n\n            'while': {\n                signature: 'while condition stmt',\n                description: 'Loop while condition is true',\n                example: 'while (i < 10) {\\n  i = i + 1;\\n}'\n            },\n\n            'for': {\n                signature: 'for range stmt',\n                description: 'Iterate over a range. Use @i(level=0) to access current iteration index.',\n                example: 'for (0..10) {\\n  @print(@i());\\n}'\n            },\n\n            'do': {\n                signature: 'do stmt while condition',\n                description: 'Do-while loop (executes at least once)',\n                example: 'do {\\n  @print(\"hello\");\\n} while (false);'\n            },\n\n            'return': {\n                signature: 'return [expr]',\n                description: 'Return from a function with optional value',\n                example: 'return x + y;'\n            },\n\n            'defer': {\n                signature: 'defer expr',\n                description: 'Defer expression execution until scope exit (LIFO order)',\n                example: 'defer file.close();'\n            },\n\n            'throw': {\n                signature: 'throw error',\n                description: 'Throw an error. Function must have an error union return type. Error must match function error type.',\n                example: 'fn process() -> MyError!void {\\n  throw MyError.Failed;\\n}'\n            },\n\n            'break': {\n                signature: 'break',\n                description: 'Break out of a loop'\n            },\n\n            'continue': {\n                signature: 'continue',\n                description: 'Continue to next loop iteration'\n            },\n\n            // Modifiers\n            'mut': {\n                signature: 'mut',\n                description: 'Make a variable, parameter, or reference mutable. Variables are immutable by default.',\n                example: 'let mut counter = 0;\\ncounter = counter + 1;'\n            },\n\n            'inline': {\n                signature: 'inline',\n                description: 'Hint to inline function calls',\n                example: 'inline fn add(a: i32, b: i32) -> i32 { return a + b; }'\n            },\n\n            'comptime': {\n                signature: 'comptime',\n                description: 'Evaluate at compile time',\n                example: 'comptime let SIZE = 100;'\n            },\n\n            // Operators\n            'as': {\n                signature: 'expr as type',\n                description: 'Type cast operator (explicit type conversion). Also used with single-argument type constructors like i32(value).',\n                example: 'let x = 42 as f32;\\nlet y = i32(3.14);'\n            },\n\n            'typeof': {\n                signature: 'typeof expr',\n                description: 'Get the type of an expression (returns a type value)',\n                example: 'let T = typeof x;\\nlet arr: [sizeof i32]T;'\n            },\n\n            'sizeof': {\n                signature: 'sizeof type',\n                description: 'Get the size of a type in bytes (compile-time constant)',\n                example: 'let size = sizeof i32; // 4\\nlet arr: [sizeof i64]u8;'\n            },\n\n            'try': {\n                signature: 'try expr',\n                description: 'Try an expression that may error. If error occurs, propagates it to caller (caller must have compatible error type).',\n                example: 'let result = try riskyOperation();'\n            },\n\n            'catch': {\n                signature: 'expr catch [(tag)] stmt',\n                description: 'Handle errors from expression. Optional tag captures the error value.',\n                example: 'let x = operation() catch { return 0; };\\nlet y = operation() catch (e) { @print(e); return -1; };'\n            },\n\n            'and': {\n                signature: 'expr and expr',\n                description: 'Logical AND operator (short-circuiting). Both operands must be boolean.',\n                example: 'if (x > 0 and x < 10) { ... }'\n            },\n\n            'or': {\n                signature: 'expr or expr',\n                description: 'Logical OR operator (short-circuiting). Both operands must be boolean.',\n                example: 'if (x == 0 or x == 1) { ... }'\n            },\n\n            'new': {\n                signature: 'new Type { fields... }',\n                description: 'Allocate and initialize a struct. Can be used with or without explicit type name in context.',\n                example: 'let ptr = new Point { x: 10, y: 20 };\\nlet p: Point = { x: 5, y: 5 };'\n            },\n\n            'from': {\n                signature: 'from',\n                description: 'Specify module path in use statement',\n                example: 'use MyType from \"./types.k\";\\nuse * as utils from \"./utils.k\";'\n            },\n\n            // Literals\n            'true': {\n                signature: 'true',\n                description: 'Boolean true value'\n            },\n\n            'false': {\n                signature: 'false',\n                description: 'Boolean false value'\n            },\n\n            'null': {\n                signature: 'null',\n                description: 'Null value (absence of value). Can be assigned to optional types and pointers.'\n            },\n\n            'und': {\n                signature: 'und',\n                description: 'Undefined value (uninitialized). Can be assigned to optional types.'\n            },\n\n            // unreachable expr\n            'unreachable': {\n                signature: 'unreachable',\n                description: 'Unreachable expression. Panics if reached.'\n            },\n\n            // noreturn type\n            'noreturn': {\n                signature: 'noreturn',\n                description: 'Type for functions that never return'\n            }\n        },\n\n        // ═══ Builtin Documentation ═══\n        builtinDocs: {\n            '@print':\n                '```kemet\\nfn @print(text: any) -> void\\n```\\n\\n' +\n                'Built-in function to print text to standard output.\\n\\n' +\n                '**Example:**\\n```kemet\\n@print(\"Hello, World!\");\\n@print(42);\\n```',\n\n            '@i':\n                '```kemet\\nfn @i(text: any) -> void\\n```\\n\\n' +\n                'Loop iteration index (available in `for` loops).\\n\\n' +\n                '**Example:**\\n```kemet\\nfor (0..10) {\\n  @print(@i(0)); // prints 0, 1, 2, ..., 9\\n}\\n```',\n\n            '@assert':\n                '```kemet\\nfn @assert(condition: bool) -> void\\n```\\n\\n' +\n                'Built-in assertion function for testing. Panics if condition is false.\\n\\n' +\n                '**Example:**\\n```kemet\\ntest \"math\" {\\n  @assert(1 + 1 == 2);\\n  @assert(5 * 5 == 25);\\n}\\n```',\n\n            'self':\n                '```kemet\\nself\\n```\\n\\n' +\n                'Reference to the current instance (available in struct methods). Static methods can only use `self` to access static members.\\n\\n' +\n                '**Example:**\\n```kemet\\nstruct {\\n  x: i32;\\n  y: i32;\\n  \\n  fn distance(self) -> f32 {\\n    return sqrt(self.x * self.x + self.y * self.y);\\n  }\\n  \\n  static count: i32 = 0;\\n  static fn getCount() -> i32 {\\n    return self.count; // OK: accessing static member\\n  }\\n}\\n```',\n\n            'selferr':\n                '```kemet\\nselferr\\n```\\n\\n' +\n                'Reference to the function\\'s self-group error set. Only available in functions with inline error set syntax (errset{...}!).\\n\\n' +\n                '**Example:**\\n```kemet\\nfn process() -> errset{IOError, ParseError}!void {\\n  if (failed) {\\n    throw selferr.IOError;\\n  }\\n}\\n```'\n        },\n\n        // ═══ LSP Settings ═══\n        triggerCharacters: ['.', ':', '@', ' ', '(', '{'],\n        fileExtension: '.k'\n    };\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// parser_rules.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import * as ParserLib       from '@je-es/parser';\n    import * as AST             from '@je-es/ast';\n    import { Expr }             from '../rules/Expr';\n    import { Stmt }             from '../rules/Stmt';\n    import { Type }             from '../rules/Type';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ INIT ════════════════════════════════════════╗\n\n    export const parserRules : ParserLib.Rules = [\n\n        ParserLib.createRule('Root',\n            ParserLib.oneOrMore(ParserLib.rule('Stmt')),\n            {\n                build: (data: ParserLib.Result) => {\n                    const seq_array = data.getRepeatResult()!;\n                    const stmts : AST.StmtNode[] = seq_array.map((x) => x.getCustomData()! as AST.StmtNode);\n                    return ParserLib.Result.createAsCustom('passed', 'root', stmts, data.span);\n                }\n            }\n        ),\n\n        ParserLib.createRule('Ident',\n            ParserLib.token('ident'),\n            {\n                build: (data: ParserLib.Result) => {\n                    const identResult = data.getTokenData()!;\n\n                    return ParserLib.Result.createAsCustom('passed', 'ident',\n                        AST.IdentNode.create( identResult.span, identResult.value!, false),\n                        data.span\n                    );\n                },\n\n                errors: [ ParserLib.error(0, \"Expected identifier\") ]\n            }\n        ),\n\n        // Include required rules\n        ...Type,\n        ...Expr,\n        ...Stmt,\n    ];\n\n    export const parserSettings : ParserLib.ParserSettings = {\n        startRule       : 'Root',\n        errorRecovery   : { mode: 'resilient', maxErrors: 99 },\n        ignored         : ['ws', 'comment'],\n        debug           : 'off',\n        maxDepth        : 9999,\n        maxCacheSize    : 1024, // 1GB\n    };\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// Expr.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import * as ParserLib       from '@je-es/parser';\n    import * as AST             from '@je-es/ast';\n    import { ParseError }       from '@je-es/parser';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ INIT ════════════════════════════════════════╗\n\n    // TODO: There are some rules that need to be updated to work with the new style.\n    export const Expr: ParserLib.Rules = [\n\n        // ════════════ ROOT ════════════\n\n            ParserLib.createRule('Expr',\n                ParserLib.seq(\n                    ParserLib.optional(\n                        ParserLib.choice(\n                            ParserLib.token('typeof'),\n                            ParserLib.token('sizeof'),\n                        )\n                    ),\n                    ParserLib.rule('AsExpr'),\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n\n                        // ══════════ Extract Data ════════\n                            const seq_array     = data.getSequenceResult()!;\n\n                            const isSpecial     = seq_array[0].isOptionalPassed();\n                            const specialType   : 'typeof' | 'sizeof' | null = isSpecial\n                                ? seq_array[0].getOptionalResult()!.getChoiceResult()!.getTokenValue()! as 'typeof' | 'sizeof'\n                                : null;\n                            const specialSan  = isSpecial ? seq_array[0].getOptionalResult()!.getChoiceResult()!.span : undefined;\n                            const exprResult    = seq_array[1];\n                            const expr = exprResult.getCustomData()! as AST.ExprNode;\n\n                            let final_expr = expr;\n                            while(final_expr.isParen()) final_expr = final_expr.getParen()!.source;\n\n                        // ══════ Syntax validation ══════\n\n                            // if sizeof and non-type expre\n                            if(specialType === 'sizeof' && !final_expr.isType()) {\n                                throw {\n                                    msg: \"Expected type expression after `sizeof`\",\n                                    span: expr.span,\n                                } as ParseError;\n                            }\n\n                        // ══════ Build AST ══════\n\n                            const result = specialType === 'typeof'\n                                ? AST.ExprNode.asTypeof(data.span, expr)\n                                : specialType === 'sizeof'\n                                    ? AST.ExprNode.asSizeof(data.span, expr)\n                                    : expr;\n                            return ParserLib.Result.createAsCustom('passed', 'expr', result, data.span);\n                    },\n                    errors: [ParserLib.error(() => true, \"Expected expression\")]\n                }\n            ),\n\n        // ════════════ ---- ════════════\n\n            ParserLib.createRule('AsExpr',\n                ParserLib.seq(\n                    // base <CatchPoint>\n                    ParserLib.rule('OrelseExpr'),\n                    // as type\n                    ParserLib.optional(\n                        ParserLib.seq(\n                            ParserLib.token('as'),\n                            ParserLib.optional(ParserLib.choice(\n                                ParserLib.rule('Type'), // only ident\n                                ParserLib.rule('Stmt'), // reject\n                            ))\n                        )\n                    )\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n\n                        // ══════════ Extract Data ════════\n\n                            const seq_array     = data.getSequenceResult()!;\n                            const baseResult    = seq_array[0];\n                            const isAs          = seq_array[1].isOptionalPassed();\n                            const isType        = seq_array[1].isOptionalPassed()\n                                                ? seq_array[1].getOptionalResult()!.getSequenceResult()![1].isOptionalPassed()! &&\n                                                  seq_array[1].getOptionalResult()!.getSequenceResult()![1].getOptionalResult()!.getChoiceIndex()! === 0\n                                                : false;\n\n                            if(!seq_array[1].isOptionalPassed()) { return baseResult; }\n\n\n                            const base          = baseResult.getCustomData()! as AST.ExprNode;\n                            const type          = isType ? seq_array[1].getOptionalResult()!.getSequenceResult()![1].getOptionalResult()!.getChoiceResult()!.getCustomData()! as AST.TypeNode : undefined;\n\n                            const asSpan        = isAs ? seq_array[1].getOptionalResult()!.getSequenceResult()![0].span : data.span;\n\n                        // ══════ Syntax validation ══════\n\n                            {\n                                // 'as' without type\n                                if(isAs && !isType) {\n                                    throw {\n                                        msg: \"Expected type after `as` keyword\",\n                                        span: asSpan\n                                    } as ParseError;\n                                }\n\n                            }\n\n                        // ══════════ Build AST ══════════\n\n                            const result    = AST.ExprNode.asAs(data.span, base, type!);\n                            return ParserLib.Result.createAsCustom('passed', 'as-expr', result, result.span);\n                    }\n                }\n            ),\n\n        // ════════════ ---- ════════════\n\n            ParserLib.createRule('OrelseExpr',\n                ParserLib.seq(\n                    // base <CatchPoint>\n                    ParserLib.rule('RangeExpr'),\n                    // ?? expr ...\n                    ParserLib.zeroOrMore(\n                        ParserLib.seq(\n                            // ?? <CatchPoint>\n                            ParserLib.token('??'),\n                            // expr\n                            ParserLib.optional(ParserLib.rule('RangeExpr'))\n                        )\n                    )\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n\n                        // ══════════ Extract Data ════════\n\n                            const seq_array     = data.getSequenceResult()!;\n                            const base          = seq_array[0];\n                            const rest          = seq_array[1].getRepeatResult()!;\n\n                            if (rest.length === 0) { return base; }\n\n                            let current = base.getCustomData()! as AST.ExprNode;\n\n                        // ══════ Syntax validation ══════\n\n                            for (const item of rest) {\n                                // Extract Data\n                                const seq       = item.getSequenceResult()!;\n                                const isRight   = seq[1].isOptionalPassed();\n                                const right     = isRight ? seq[1].getOptionalResult()!.getCustomData()! as AST.ExprNode : undefined;\n                                const signSpan  = seq[0].span;\n                                const span      = {\n                                    start: current.span.start,\n                                    end: isRight ? right!.span.end : current.span.end\n                                };\n\n                                // Syntax validation\n                                if (!isRight) {\n                                    throw {\n                                        msg: \"Expected expression after `??`\",\n                                        span: signSpan\n                                    } as ParseError;\n                                }\n\n                                // Build AST\n                                current = AST.ExprNode.asOrelse(span, current, right!);\n                            }\n\n                        // ══════════ Build AST ══════════\n\n                            return ParserLib.Result.createAsCustom('passed', 'null-coalescing-expr', current, current.span);\n                    }\n                }\n            ),\n\n        // ════════════ ---- ════════════\n\n            ParserLib.createRule('RangeExpr',\n                ParserLib.seq(\n                    ParserLib.rule('TryExpr'),\n\n                    ParserLib.optional(\n                        ParserLib.seq(\n                            ParserLib.choice(\n                                ParserLib.token('..'),\n                                ParserLib.token('..=')\n                            ),\n                            ParserLib.optional(ParserLib.rule('Expr'))\n                        )\n                    )\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        const seq_array = data.getSequenceResult()!;\n\n                        // without range\n                        const isRangePassed = seq_array[1].isOptionalPassed();\n                        if (!isRangePassed) { return seq_array[0]; }\n\n                        // with range\n                        else {\n                            const left = seq_array[0].getCustomData()! as AST.ExprNode;\n\n                            const opt_seq_array = seq_array[1].getOptionalResult()!.getSequenceResult()!;\n\n                            const operator = opt_seq_array[0].getChoiceResult()!.getTokenValue()!;\n                            const rangeType = operator === '..' ? 'exclusive' : 'inclusive';\n\n                            const isRightPassed = opt_seq_array[1].isOptionalPassed();\n                            const right = isRightPassed ? opt_seq_array[1].getOptionalResult()!.getCustomData()! as AST.ExprNode : null;\n\n                            // x..y | x..\n                            return ParserLib.Result.createAsCustom('passed', 'range-expr',\n                                AST.ExprNode.asRange(data.span, left, rangeType, right),\n                                data.span\n                            );\n                        }\n                    }\n                }\n            ),\n\n        // ════════════ ---- ════════════\n\n            ParserLib.createRule('TryExpr',\n                ParserLib.seq(\n                    ParserLib.optional( ParserLib.token('try') ),\n                    ParserLib.rule('CatchExpr'),\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        const seq_array = data.getSequenceResult()!;\n                        const isTry = seq_array[0].isOptionalPassed();\n\n                        if(!isTry) return seq_array[1];\n\n                        const expr = seq_array[1].getCustomData()! as AST.ExprNode;\n                        const result = AST.ExprNode.asTry(data.span, expr);\n\n                        // Return\n                        return ParserLib.Result.createAsCustom('passed', 'try-expr', result, data.span);\n\n                    },\n                    errors: [ParserLib.error(() => true, \"Expected expression\")]\n                }\n            ),\n\n            ParserLib.createRule('CatchExpr',\n                ParserLib.seq(\n                    ParserLib.rule('ControlFlowExpr'),\n                    ParserLib.optional(\n                        ParserLib.seq(\n                            ParserLib.token('catch'),\n\n                            ParserLib.optional(\n                                ParserLib.seq(\n                                    ParserLib.token('('),\n                                    ParserLib.rule('Expr'),\n                                    ParserLib.token(')')\n                                )\n                            ),\n\n                            ParserLib.rule('Stmt')\n                        )\n                    )\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        const seq_array = data.getSequenceResult()!;\n                        if(!seq_array[1].isOptionalPassed()) return seq_array[0];\n\n                        const opt_seq_array : ParserLib.Result[] = seq_array[1].getOptionalResult()!.getSequenceResult()!;\n                        const leftExpr = seq_array[0].getCustomData()! as AST.ExprNode;\n                        const isTagged = opt_seq_array[1].isOptionalPassed();\n                        const tag = isTagged ? opt_seq_array[1].getOptionalResult()!.getSequenceResult()![1].getCustomData()! as AST.ExprNode : null;\n                        const rightStmt = opt_seq_array[2].getCustomData()! as AST.StmtNode;\n\n                        const result = AST.ExprNode.asCatch({ start: leftExpr.span.start, end: rightStmt.span.end },\n                            leftExpr,\n                            tag,\n                            rightStmt\n                        );\n\n                        // Return\n                        return ParserLib.Result.createAsCustom('passed', 'catch-expr', result, data.span);\n                    },\n                }\n            ),\n\n        // ════════════ ---- ════════════\n\n            ParserLib.createRule('ControlFlowExpr',\n                ParserLib.choice(\n                    ParserLib.rule('IfExpr'),\n                    ParserLib.rule('MatchExpr'),\n                    ParserLib.rule('AssignmentExpr')\n                ),\n                {\n                    build: (data: ParserLib.Result) => data.getChoiceResult()!,\n                }\n            ),\n\n            ParserLib.createRule('IfExpr',\n                ParserLib.seq(\n                    // if <CatchPoint>\n                    ParserLib.token('if'),\n                    // expression\n                    ParserLib.optional(ParserLib.rule('Expr')),\n                    // statement\n                    ParserLib.optional(ParserLib.rule('Stmt')),\n                    // else\n                    ParserLib.optional(\n                        ParserLib.seq(\n                            // else <CatchPoint>\n                            ParserLib.token('else'),\n                            // statement\n                            ParserLib.optional(ParserLib.rule('Stmt'))\n                        )\n                    )\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n\n                        // ══════════ Extract Data ════════\n\n                            const seq_array = data.getSequenceResult()!;\n\n                            const isIfExpr          = seq_array[1].isOptionalPassed();\n                            const isIfStmt          = seq_array[2].isOptionalPassed();\n                            const iElse             = seq_array[3].isOptionalPassed();\n                            const isElseStmt        = iElse ? seq_array[3].getOptionalResult()!.getSequenceResult()![1].isOptionalPassed() : false;\n\n                            const ifSpan            = seq_array[0].span;\n                            const elseSpan          = iElse ? seq_array[3].getOptionalResult()!.getSequenceResult()![0].span : undefined;\n\n                            const ifExpr            = isIfExpr ? seq_array[1].getOptionalResult()!.getCustomData()! as AST.ExprNode : undefined;\n                            const ifStmt            = isIfStmt ? seq_array[2].getOptionalResult()!.getCustomData()! as AST.StmtNode : undefined;\n                            const elseStmt          = isElseStmt ? seq_array[3].getOptionalResult()!.getSequenceResult()![1].getOptionalResult()!.getCustomData()! as AST.StmtNode : null;\n\n                        // ══════ Syntax validation ══════\n\n                            // Missing if expression\n                            if(!isIfExpr) {\n                                throw {\n                                    msg: \"Expected expression after `if` keyword\",\n                                    span: ifSpan,\n                                } as ParseError;\n                            }\n\n                            // Missing if statement\n                            if(!isIfStmt) {\n                                throw {\n                                    msg: \"Expected statement after expression\",\n                                    span: ifExpr!.span,\n                                } as ParseError;\n                            }\n\n                            // Missing else statement\n                            if(iElse && !isElseStmt) {\n                                throw {\n                                    msg: \"Expected statement after `else` keyword\",\n                                    span: elseSpan,\n                                } as ParseError;\n                            }\n\n\n                        // ══════════ Build AST ══════════\n\n                            const result = AST.ExprNode.asIf(data.span, ifExpr!, ifStmt!, elseStmt);\n                            return ParserLib.Result.createAsCustom('passed', 'if-expr', result, data.span);\n                    },\n                }\n            ),\n\n            ParserLib.createRule('MatchExpr',\n                ParserLib.seq(\n                    // match <catchPoint>\n                    ParserLib.token('match'),\n                    // expression\n                    ParserLib.optional(ParserLib.rule('Expr')),\n                    // {\n                    ParserLib.optional(ParserLib.token(`{`)),\n                    // cases\n                    ParserLib.zeroOrMore( ParserLib.rule('Case') ),\n                    // default\n                    ParserLib.optional(ParserLib.rule('DefaultCase')),\n                    // }\n                    ParserLib.optional(ParserLib.token(`}`))\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n\n                        // ══════════ Extract Data ════════\n\n                            const seq_array = data.getSequenceResult()!;\n\n                            const isMatchExpr       = seq_array[1].isOptionalPassed();\n                            const isOpeningParen    = seq_array[2].isOptionalPassed();\n                            const isCases           = seq_array[3].getRepeatCount()! > 0;\n                            const isDefaultCase     = seq_array[4].isOptionalPassed();\n                            const isClosingParen    = seq_array[5].isOptionalPassed();\n\n                            const matchSpan         = seq_array[0].span;\n                            const openingParenSpan  = isOpeningParen ? seq_array[2].span : undefined;\n                            const closingParenSpan  = isClosingParen ? seq_array[5].span : undefined;\n\n                            const matchExpr         = isMatchExpr ? seq_array[1].getOptionalResult()!.getCustomData()! as AST.ExprNode : undefined;\n                            const casesArray        = isCases ? seq_array[3].getRepeatResult()!.map(member => member.getCustomData()! as AST.CaseNode) : [];\n                            const defaultCase       = isDefaultCase ? seq_array[4].getOptionalResult()!.getCustomData()! as AST.DefaultNode : null;\n\n                        // ══════ Syntax validation ══════\n\n                            // Missing match expression\n                            if(!isMatchExpr) {\n                                throw {\n                                    msg: \"Expected expression after `match` keyword\",\n                                    span: matchSpan,\n                                } as ParseError;\n                            }\n\n                            // Missing opening parenthesis\n                            if(!isOpeningParen) {\n                                throw {\n                                    msg: \"Expected `{` after match expression\",\n                                    span: matchExpr!.span,\n                                } as ParseError;\n                            }\n\n                            // Missing match cases\n                            if(!isCases && !isDefaultCase) {\n                                throw {\n                                    msg: \"Expected match cases\",\n                                    span: openingParenSpan,\n                                } as ParseError;\n                            }\n\n                            // Missing closing parenthesis\n                            if(!isClosingParen) {\n                                let last_span = openingParenSpan;\n                                if(casesArray.length > 0) {\n                                    last_span = casesArray[casesArray.length - 1].span;\n                                } else if(defaultCase) {\n                                    last_span = defaultCase.span;\n                                }\n\n                                throw {\n                                    msg: \"Expected `}` after match cases\",\n                                    span: last_span,\n                                } as ParseError;\n                            }\n\n                        // ══════ Build AST ══════\n\n                            const result = AST.ExprNode.asMatch(data.span, matchExpr!, casesArray, defaultCase);\n                            return ParserLib.Result.createAsCustom('passed', 'switch-expr', result, data.span);\n                    },\n                }\n            ),\n\n            ParserLib.createRule('Case',\n                ParserLib.seq(\n                    // expression <catchPoint>\n                    ParserLib.rule('Expr'),\n                    // =>\n                    ParserLib.optional(ParserLib.token('=>')),\n                    // statement\n                    ParserLib.optional(ParserLib.rule('Stmt'))\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n\n                        // ══════════ Extract Data ════════\n\n                            const seq_array = data.getSequenceResult()!;\n\n                            const isArrow       = seq_array[1].isOptionalPassed();\n                            const isStmt        = seq_array[2].isOptionalPassed();\n\n                            const caseExpr      = seq_array[0].getCustomData()! as AST.ExprNode;\n                            const arrowSpan     = isArrow ? seq_array[1].span : undefined;\n                            const stmt          = isStmt ? seq_array[2].getOptionalResult()!.getCustomData()! as AST.StmtNode : null;\n\n                        // ══════ Syntax validation ══════\n\n                            // Missing arrow\n                            if(!isArrow) {\n                                throw {\n                                    msg: \"Expected arrow after expression\",\n                                    span: caseExpr!.span,\n                                } as ParseError;\n                            }\n\n                            // Missing statement\n                            if(!isStmt) {\n                                throw {\n                                    msg: \"Expected statement after arrow\",\n                                    span: arrowSpan,\n                                } as ParseError;\n                            }\n\n                        // ══════ Build AST ══════\n\n                            const result = AST.CaseNode.create(data.span, caseExpr!, stmt);\n                            return ParserLib.Result.createAsCustom('passed', 'case', result, data.span);\n                    },\n                }\n            ),\n\n            ParserLib.createRule('DefaultCase',\n                ParserLib.seq(\n                    // default <catchPoint>\n                    ParserLib.token('default'),\n                    // =>\n                    ParserLib.optional(ParserLib.token('=>')),\n                    // statement\n                    ParserLib.optional(ParserLib.rule('Stmt'))\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n\n                        // ══════════ Extract Data ════════\n\n                            const seq_array = data.getSequenceResult()!;\n\n                            const isArrow       = seq_array[1].isOptionalPassed();\n                            const isStmt        = seq_array[2].isOptionalPassed();\n\n                            const defaultSpan   = seq_array[0].span;\n                            const arrowSpan     = isArrow ? seq_array[1].span : undefined;\n                            const stmt          = isStmt ? seq_array[2].getOptionalResult()!.getCustomData()! as AST.StmtNode : null;\n\n                        // ══════ Syntax validation ══════\n\n                            // Missing arrow\n                            if(!isArrow) {\n                                throw {\n                                    msg: \"Expected arrow after `default` keyword\",\n                                    span: defaultSpan,\n                                } as ParseError;\n                            }\n\n                            // Missing statement\n                            if(!isStmt) {\n                                throw {\n                                    msg: \"Expected statement after arrow\",\n                                    span: arrowSpan,\n                                } as ParseError;\n                            }\n\n                        // ══════ Build AST ══════\n\n                            const result = AST.DefaultNode.create(data.span, stmt!);\n                            return ParserLib.Result.createAsCustom('passed', 'default-case', result, data.span);\n                    },\n                }\n            ),\n\n        // ════════════ ---- ════════════\n\n            ParserLib.createRule('AssignmentExpr',\n                ParserLib.seq(\n                    ParserLib.rule('ConditionalExpr'),\n                    ParserLib.optional(\n                        ParserLib.seq(\n                            ParserLib.choice(\n                                ParserLib.token('='),\n                                ParserLib.token('+='),\n                                ParserLib.token('-='),\n                                ParserLib.token('*='),\n                                ParserLib.token('/='),\n                                ParserLib.token('%='),\n                            ),\n                            ParserLib.rule('Expr')\n                        )\n                    )\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        const seq_array = data.getSequenceResult()!;\n\n                        if(!seq_array[1].isOptionalPassed()) return seq_array[0];\n\n                        const opt_seq_array : ParserLib.Result[] = seq_array[1].getOptionalResult()!.getSequenceResult()!;\n                        const left = seq_array[0].getCustomData()! as AST.ExprNode;\n                        const operator = opt_seq_array[0].getChoiceResult()!.getTokenValue()!;\n                        const right = opt_seq_array[1].getCustomData()! as AST.ExprNode;\n\n                        const result = AST.ExprNode.asBinary({ start: left.span.start, end: right.span.end },\n                            left,\n                            operator,\n                            right\n                        );\n\n                        // Return\n                        return ParserLib.Result.createAsCustom('passed', 'assignment-expr', result, data.span);\n                    },\n                }\n            ),\n\n        // ════════════ ---- ════════════\n\n            ParserLib.createRule('ConditionalExpr',\n                ParserLib.seq(\n                    ParserLib.rule('LogicalOrExpr'),\n                    ParserLib.optional(\n                        ParserLib.seq(\n                            ParserLib.token('?'),\n                            ParserLib.rule('Expr'),\n                            ParserLib.token(':'),\n                            ParserLib.rule('Expr')\n                        )\n                    )\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        const data_seq_array = data.getSequenceResult()!;\n                        if(!data_seq_array[1].isOptionalPassed()) return data_seq_array[0];\n\n                        const seq_array : ParserLib.Result[] = data_seq_array[1].getOptionalResult()!.getSequenceResult()!;\n                        const condition = data_seq_array[0].getCustomData()! as AST.ExprNode;\n                        const trueExpr = seq_array[1].getCustomData()! as AST.ExprNode;\n                        const falseExpr = seq_array[3].getCustomData()! as AST.ExprNode;\n\n                        const result = AST.ExprNode.asConditional({ start: condition.span.start, end: falseExpr.span.end },\n                            condition,\n                            trueExpr,\n                            falseExpr\n                        );\n\n                        // Return\n                        return ParserLib.Result.createAsCustom('passed', 'conditional-expr', result, data.span);\n                    }\n                }\n            ),\n\n        // ════════════ ---- ════════════\n\n            ParserLib.createRule('PrefixExpr',\n                ParserLib.seq(\n                    ParserLib.zeroOrMore(\n                        ParserLib.choice(\n                            ParserLib.token('++'),\n                            ParserLib.token('--'),\n                            ParserLib.token('&'),\n                            ParserLib.token('+'),\n                            ParserLib.token('-'),\n                            ParserLib.token('!'),\n                            ParserLib.token('~')\n                        )\n                    ),\n                    ParserLib.rule('PostfixExpr')\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        const seq_array = data.getSequenceResult()!;\n                        const or_this : ParserLib.Result = seq_array[1];\n\n                        const repeat_array : ParserLib.Result[] = seq_array[0].getRepeatResult()!;\n\n                        if(!repeat_array.length){\n                            return or_this;\n                        }\n\n                        let result = or_this.getCustomData()! as AST.ExprNode;\n                        const operations = repeat_array;\n\n                        // Same logic as before\n                        for (const _op of operations) {\n                            const op = _op.getChoiceResult()!;\n\n                            // Prefix Increment\n                            if (op.getTokenValue() === '++') {\n                                result = AST.ExprNode.asPreIncrement({ start: op.span.start, end: result.span.end },\n                                    result\n                                );\n                            }\n\n                            // Prefix Decrement\n                            else if (op.getTokenValue() === '--') {\n                                result = AST.ExprNode.asPreDecrement({ start: op.span.start, end: result.span.end },\n                                    result\n                                );\n                            }\n\n                            // Reference\n                            else if (op.getTokenValue() === '&') {\n                                result = AST.ExprNode.asReference({ start: op.span.start, end: result.span.end },\n                                    result\n                                );\n                            }\n\n                            // Unary Plus\n                            else if (op.getTokenValue() === '+') {\n                                result = AST.ExprNode.asUnaryPlus({ start: op.span.start, end: result.span.end },\n                                    result\n                                );\n                            }\n\n                            // Unary Minus\n                            else if (op.getTokenValue() === '-') {\n                                result = AST.ExprNode.asUnaryMinus({ start: op.span.start, end: result.span.end },\n                                    result\n                                );\n                            }\n\n                            // Logical Not\n                            else if (op.getTokenValue() === '!') {\n                                result = AST.ExprNode.asLogicalNot({ start: op.span.start, end: result.span.end },\n                                    result\n                                );\n                            }\n\n                            // Bitwise Not\n                            else if (op.getTokenValue() === '~') {\n                                result = AST.ExprNode.asxBitwiseNot({ start: op.span.start, end: result.span.end },\n                                    result\n                                );\n                            }\n                        }\n\n                        // Return\n                        return ParserLib.Result.createAsCustom('passed', 'prefix-expr', result, data.span);\n                    },\n                }\n            ),\n\n        // ════════════ ---- ════════════\n\n            ParserLib.createRule('PostfixExpr',\n                ParserLib.seq(\n                    ParserLib.rule('PrimaryExpr'),\n                    ParserLib.zeroOrMore(\n                        ParserLib.choice(\n                            ParserLib.rule('ArrayAccess'),\n                            ParserLib.rule('CallSuffix'),\n                            ParserLib.rule('MemberAccessSuffix'),\n                            ParserLib.token('.*'),\n                            ParserLib.token('++'),\n                            ParserLib.token('--'),\n                        )\n                    )\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        const seq_array = data.getSequenceResult()!;\n                        const or_this : ParserLib.Result = seq_array[0];\n\n                        const repeat_array : ParserLib.Result[] = seq_array[1].getRepeatResult()!;\n\n                        if(!repeat_array.length){\n                            return or_this;\n                        }\n\n                        let result = or_this.getCustomData()! as AST.ExprNode;\n                        const operations = repeat_array;\n\n                        // Same logic as before, just more efficient parsing\n                        for (const choice_res of operations) {\n                            const op = choice_res.getChoiceResult()!;\n                            // Post Increment\n                            if (op.getTokenValue() === '++') {\n                                result = AST.ExprNode.asPreIncrement({ start: result.span.start, end: op.span.end },\n                                    result\n                                );\n                            }\n\n                            // Post Decrement\n                            else if (op.getTokenValue() === '--') {\n                                result = AST.ExprNode.asPostDecrement({ start: result.span.start, end: op.span.end },\n                                    result\n                                );\n                            }\n\n                            // Dereference\n                            else if (op.getTokenValue() === '.*') {\n                                result = AST.ExprNode.asDereference({ start: result.span.start, end: op.span.end },\n                                    result\n                                );\n                            }\n\n                            // Member Access\n                            else if (op.isCustom('member-access-suffix')) {\n                                const memberResult = op.getCustomData()! as {\n                                    expr: AST.ExprNode,\n                                    optional: boolean\n                                };\n                                result = AST.ExprNode.asMemberAccess({ start: result.span.start, end: op.span.end },\n                                    result,\n                                    memberResult.expr,\n                                    memberResult.optional\n                                );\n                            }\n\n                            // CallSuffix\n                            else if (op.isCustom('call-suffix')) {\n\n                                // call expr must not be type\n                                if(result.isType()) {\n\n                                    // if like `i32(..)` so return expr -> type -> cast type\n                                    if((op.getCustomData()! as AST.ExprNode[]).length === 1) {\n                                        result = AST.ExprNode.asAs({ start: result.span.start, end: op.span.end },\n                                            (op.getCustomData()! as AST.ExprNode[])[0],\n                                            result.getType()!,\n                                        );\n\n                                        return ParserLib.Result.createAsCustom('passed', 'as-expr', result, result.span);\n                                    }\n\n                                    // otherwise\n                                    throw {\n                                        msg: \"Type cannot be called as function\",\n                                        span: result.span\n                                    } as ParseError;\n                                }\n\n                                result = AST.ExprNode.asCall({ start: result.span.start, end: op.span.end },\n                                    result,\n                                    op.getCustomData()! as AST.ExprNode[]\n                                );\n                            }\n\n                            // Array Access\n                            else if (op.isCustom('array-access')) {\n                                result = AST.ExprNode.asArrayAccess({ start: result.span.start, end: op.span.end },\n                                    result,\n                                    op.getCustomData()! as AST.ExprNode\n                                );\n                            }\n                        }\n\n                        return ParserLib.Result.createAsCustom('passed', 'postfix-expr', result, data.span);\n                    }\n                }\n            ),\n\n            ParserLib.createRule('MemberAccessSuffix',\n                ParserLib.seq(\n                    ParserLib.optional(ParserLib.token('?')),\n                    ParserLib.token('.'),\n                    ParserLib.rule('PrimaryExpr'),\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        const isOptional = data.getSequenceResult()![0].isOptionalPassed();\n                        const expr = data.getSequenceResult()![2].getCustomData()! as AST.ExprNode;\n                        return ParserLib.Result.createAsCustom('passed', 'member-access-suffix', {\n                            expr,\n                            optional: isOptional\n                        }, data.span);\n                    },\n\n                    errors: [\n                        ParserLib.error(0, \"Expected '.' for member access\"),\n                        ParserLib.error(1, \"Expected identifier after '.'\"),\n                    ]\n                }\n            ),\n\n            ParserLib.createRule('CallSuffix',\n                ParserLib.seq(\n                    ParserLib.token('('),\n                    ParserLib.zeroOrOne(ParserLib.rule('ArgumentList')),\n                    // Edit :\n                    ParserLib.optional(ParserLib.token(')'))\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n\n                        // ══════════ Extract Data ════════\n\n                            const seq_array = data.getSequenceResult()!;\n                            const isClosed = seq_array[2].isOptionalPassed();\n                            const repeat_array = seq_array[1].getRepeatResult()!;\n                            const args = repeat_array.length > 0 ? repeat_array[0].getCustomData()! as AST.ExprNode : [];\n\n                        // ══════ Syntax validation ══════\n\n                            // Missing ')'\n                            if (!isClosed) {\n                                throw {\n                                    msg: \"Expected ')' after argument list\",\n                                    span: data.span\n                                } as ParseError;\n                            }\n\n                        // ══════ Build AST ══════\n\n                            return ParserLib.Result.createAsCustom('passed', 'call-suffix', args, data.span);\n                    },\n\n                    errors: [\n                        ParserLib.error(0, \"Expected '(' for function call\"),\n                        ParserLib.error(1, \"Expected ')' for function call\"),\n                        ParserLib.error(2, \"Expected ')' for function call\"),\n                    ]\n                }\n            ),\n\n            ParserLib.createRule('ArgumentList',\n                ParserLib.zeroOrMore(\n                    ParserLib.rule('Expr'),\n                    ParserLib.token(',')\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        const repeat_array = data.getRepeatResult()!;\n                        const args : AST.ExprNode[] = [];\n                        for(const x of repeat_array) { args.push(x.getCustomData()! as AST.ExprNode); }\n                        return ParserLib.Result.createAsCustom('passed', 'argument-list', args, data.span);\n                    },\n\n                    errors: [\n                        ParserLib.error(0, \"Expected argument list\"),\n                    ]\n                }\n            ),\n\n            ParserLib.createRule('ArrayAccess',\n                ParserLib.seq(\n                    ParserLib.token('['),\n                    ParserLib.rule('Expr'),\n                    ParserLib.token(']')\n                ),\n                {\n\n                    build: (data: ParserLib.Result) => {\n                        return ParserLib.Result.createAsCustom('passed', 'array-access', data.getSequenceResult()![1].getCustomData()!, data.span);\n                    },\n\n                    errors: [\n                        ParserLib.error(0, \"Expected '[' for array access\"),\n                        ParserLib.error(1, \"Expected Expr for array access\"),\n                        ParserLib.error(2, \"Expected ']' for array access\"),\n                    ]\n                }\n            ),\n\n        // ════════════ ---- ════════════\n\n            ParserLib.createRule('PrimaryExpr',\n                ParserLib.choice(\n                    ParserLib.rule('UnreachableExpr'),\n                    ParserLib.rule('ParenExpr'),\n                    ParserLib.rule('TupleExpr'),\n                    ParserLib.rule('ObjectExpr'),\n                    ParserLib.rule('IdentExpr'),\n                    ParserLib.rule('TypeExpr'),\n                    ParserLib.rule('LiteralExpr'),\n                ),\n                {\n                    build: (data: ParserLib.Result) => ParserLib.Result.createAsCustom('passed', 'primary-expr', data.getChoiceResult()!.getCustomData()!, data.span)\n                }\n            ),\n\n            ParserLib.createRule('IdentExpr',\n                ParserLib.seq(\n                    ParserLib.optional(ParserLib.token('@')),\n                    ParserLib.token('ident'),\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        const seq_array = data.getSequenceResult()!;\n                        const is_builtin = seq_array[0].isOptionalPassed();\n                        const identResult = seq_array[1];\n\n                        return ParserLib.Result.createAsCustom('passed', 'ident-expr',\n                            AST.ExprNode.asIdent( data.span, identResult.getTokenValue()!, is_builtin),\n                            data.span\n                        );\n                    },\n\n                    errors: [ ParserLib.error(0, \"Expected identifier\") ]\n                }\n            ),\n\n            ParserLib.createRule('LiteralExpr',\n                ParserLib.choice(\n                    // Integer\n                    ParserLib.token('dec'),\n                    ParserLib.token('bin'),\n                    ParserLib.token('oct'),\n                    ParserLib.token('hex'),\n\n                    // Float\n                    ParserLib.token('flt'),\n\n                    // Boolean\n                    ParserLib.token('true'),\n                    ParserLib.token('false'),\n\n                    // String\n                    ParserLib.token('slice'),\n\n                    // Character\n                    ParserLib.token('char'),\n\n                    // Null/Undefined\n                    ParserLib.token('null'),\n                    ParserLib.token('und'),\n\n                    // Array\n                    ParserLib.seq(\n                        ParserLib.token('['),\n                        ParserLib.zeroOrMore(\n                            ParserLib.rule('Expr'),\n                            ParserLib.token(',')\n                        ),\n                        ParserLib.token(']'),\n                    ),\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        const selected = data.getChoiceResult()!;\n                        let expr : AST.ExprNode | null = null;\n\n                        if(selected.isToken()) {\n                            const token = selected.getTokenData()!;\n                            switch (token.kind) {\n\n                                // Integer\n                                case 'dec':\n                                case 'bin':\n                                case 'oct':\n                                case 'hex':\n                                    expr = AST.ExprNode.asInteger(token.span, Number(token.value));\n                                    break;\n\n                                // Float\n                                case 'flt':\n                                    expr = AST.ExprNode.asFloat(token.span, Number(token.value));\n                                    break;\n\n                                // Boolean\n                                case 'true':\n                                case 'false':\n                                    expr = AST.ExprNode.asBool(token.span, token.value === 'true');\n                                    break;\n\n                                // Slice\n                                case 'slice':\n                                    expr = AST.ExprNode.asString(token.span, token.value ?? '');\n                                    break;\n\n                                // Character\n                                case 'char':\n                                    expr = AST.ExprNode.asChar(token.span, token.value ?? '');\n                                    break;\n\n                                // Null\n                                case 'null':\n                                    expr = AST.ExprNode.asNull(token.span);\n                                    break;\n\n                                // Undefined\n                                case 'und':\n                                    expr = AST.ExprNode.asUndefined(token.span);\n                                    break;\n\n                                // --\n                                default:\n                                    throw new Error(`Unknown literal kind: ${token.kind}`);\n                            }\n                        }\n\n                        else if(selected.isSequence()) {\n                            const repeat_items : ParserLib.Result[] = selected.getSequenceResult()![1].getRepeatResult()!;\n                            const exprs : AST.ExprNode[] = [];\n\n                            if(repeat_items.length > 0) {\n                                for(const r_item of repeat_items) {\n                                    const res = r_item.getCustomData();\n                                    if(!res) continue;\n                                    exprs.push(res as AST.ExprNode);\n                                }\n                            }\n\n                            expr = AST.ExprNode.asArray(\n                                data.span,\n                                exprs\n                            );\n                        }\n\n                        return ParserLib.Result.createAsCustom('passed', 'literal-expr', expr, data.span);\n                    },\n                    errors: [\n                        ParserLib.error(0, \"Expected literal expression\")\n                    ]\n                }\n            ),\n\n            ParserLib.createRule('UnreachableExpr',\n                ParserLib.token('unreachable'),\n                {\n                    build: (data: ParserLib.Result) => ParserLib.Result.createAsCustom('passed', 'unreachable-expr', AST.ExprNode.asUnreachable(data.span), data.span)\n                }\n            ),\n\n            ParserLib.createRule('ParenExpr',\n                ParserLib.seq(\n                    ParserLib.token('('),\n                    ParserLib.rule('Expr'),\n                    ParserLib.token(')')\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        const seq_array = data.getSequenceResult()!;\n\n                        const paren_expr = AST.ExprNode.asParen(\n                            data.span,\n                            seq_array[1].getCustomData()! as AST.ExprNode\n                        );\n\n                        return ParserLib.Result.createAsCustom('passed', 'paren-expr', paren_expr, data.span);\n                    },\n                }\n            ),\n\n            ParserLib.createRule('TupleExpr',\n                ParserLib.seq(\n                    ParserLib.token('.'),\n                    ParserLib.token('{'),\n                    ParserLib.rule('Expr'),\n\n                    ParserLib.oneOrMore(\n                        ParserLib.seq(\n                            ParserLib.token(','),\n                            ParserLib.rule('Expr'),\n                        ),\n                    ),\n\n\n                    ParserLib.token('}')\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        const seq_array = data.getSequenceResult()!;\n\n                        const repeat_items : ParserLib.Result[] = seq_array[3].getRepeatResult()!;\n                        const exprs : AST.ExprNode[] = [\n                            seq_array[2].getCustomData()! as AST.ExprNode\n                        ];\n\n                        if(repeat_items.length > 0) {\n                            for(const r_item of repeat_items) {\n                                const res = r_item.getSequenceResult()![1].getCustomData();\n                                if(!res) continue;\n                                exprs.push(res as AST.ExprNode);\n                            }\n                        }\n\n                        const tuple_expr = AST.ExprNode.asTuple(\n                            data.span,\n                            exprs\n                        );\n\n                        return ParserLib.Result.createAsCustom('passed', 'tuple-expr', tuple_expr, data.span);\n                    },\n                }\n            ),\n\n            ParserLib.createRule('ObjectExpr',\n                ParserLib.seq(\n                    ParserLib.optional(ParserLib.seq(\n                        ParserLib.token('new'),\n                        ParserLib.rule('Ident')\n                    )),\n                    ParserLib.token('{'),\n                    ParserLib.zeroOrMore(\n                        ParserLib.rule('ObjectProperty'),\n                        ParserLib.token(',')\n                    ),\n                    ParserLib.token('}'),\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n\n                        // ══════════ Extract Data ════════\n\n                            const seq_array         = data.getSequenceResult()!;\n                            const isIdent           = seq_array[0].isOptionalPassed();\n                            const ident             = isIdent ? seq_array[0].getOptionalResult()!.getSequenceResult()![1].getCustomData()! as AST.IdentNode  : undefined;\n\n                            const repeat_items      = seq_array[2].getRepeatResult()!;\n                            const props             = [] as AST.PropNode[];\n\n                            if (repeat_items.length > 0) {\n                                for (const r_item of repeat_items) {\n                                    const res = r_item.getCustomData();\n                                    if (!res) continue;\n                                    props.push(res as AST.PropNode);\n                                }\n                            }\n\n                        // ══════════ Build AST ══════════\n\n                            const expr = AST.ExprNode.asObject( data.span, props, ident );\n                            return ParserLib.Result.createAsCustom('passed', 'object-expr', expr, data.span);\n                    }\n                }\n            ),\n\n            ParserLib.createRule('ObjectProperty',\n                ParserLib.seq(\n                    ParserLib.rule('Ident'),\n                    ParserLib.token(':'), // TODO: why not '=' ?\n                    ParserLib.rule('Expr')\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        const seq_array = data.getSequenceResult()!;\n                        const key = seq_array[0].getCustomData()! as AST.IdentNode;\n                        const value = seq_array[2].getCustomData()! as AST.ExprNode;\n\n                        return ParserLib.Result.createAsCustom('passed', 'object-property',\n                            AST.PropNode.create(data.span, key, value),\n                            data.span\n                        );\n                    },\n                    errors: [\n                        ParserLib.error(0, \"Expected property name\"),\n                        ParserLib.error(1, \"Expected ':'\"),\n                        ParserLib.error(2, \"Expected property value\")\n                    ]\n                }\n            ),\n\n            // e.g. `let x = i32;`\n            ParserLib.createRule('TypeExpr',\n                ParserLib.rule('Type'),\n                {\n                    build: (data: ParserLib.Result) => {\n                        const typeNode = data.getCustomData()! as AST.TypeNode;\n\n                        if(typeNode.isUndefined()) {\n                            return ParserLib.Result.createAsCustom('passed', 'literal-expr',\n                                AST.ExprNode.asUndefined(typeNode.span),\n                                data.span\n                            );\n                        }\n                        else if(typeNode.isNull()) {\n                            return ParserLib.Result.createAsCustom('passed', 'literal-expr',\n                                AST.ExprNode.asNull(typeNode.span),\n                                data.span\n                            );\n                        }\n\n                        // Otherwise, return a type expression node\n                        else return ParserLib.Result.createAsCustom('passed', 'type-expr',\n                            AST.ExprNode.asType(data.span, data.getCustomData()! as AST.TypeNode),\n                            data.span\n                        );\n                    },\n                    errors: [\n                        ParserLib.error(0, \"Expected 'type'\")\n                    ]\n                }\n            ),\n\n            // e.g. `let x = i32(55);`\n            ParserLib.createRule('TypeCastExpr',\n                ParserLib.seq(\n                    ParserLib.rule('Type'),\n                    ParserLib.token('('),\n                    ParserLib.rule('Expr'),\n                    ParserLib.token(')'),\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n\n                        // ══════════ Extract Data ════════\n\n                            const seq_array = data.getSequenceResult()!;\n                            const typeNode = seq_array[0].getCustomData()! as AST.TypeNode;\n                            const exprNode = seq_array[2].getCustomData()! as AST.ExprNode;\n\n                        // ══════════ Build AST ══════════\n\n                            return ParserLib.Result.createAsCustom('passed', 'type-cast-expr',\n                                AST.ExprNode.asAs(data.span, exprNode, typeNode),\n                                data.span\n                            );\n\n                    }\n                }\n            ),\n\n        // ════════════ ---- ════════════\n\n            ParserLib.createRule('PowerExpr',\n                ParserLib.seq(\n                    ParserLib.rule('PrefixExpr'),\n                    ParserLib.zeroOrMore(\n                        ParserLib.seq(\n                            ParserLib.token('**'),\n                            ParserLib.rule('PrefixExpr')\n                        )\n                    )\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        // ══════════ Extract Data ════════\n                        const seq_array = data.getSequenceResult()!;\n                        const base = seq_array[0];\n                        const operations = seq_array[1].getRepeatResult()!;\n\n                        if (operations.length === 0) { return base; }\n\n                        // ══════════ Build AST ══════════\n                        // Power is right-associative: x**y**z = x**(y**z)\n                        // Collect all operands\n                        const allOperands: AST.ExprNode[] = [base.getCustomData()! as AST.ExprNode];\n\n                        for (const op of operations) {\n                            const opSeq = op.getSequenceResult()!;\n                            allOperands.push(opSeq[1].getCustomData()! as AST.ExprNode);\n                        }\n\n                        // Build right-associative chain from the end\n                        let result = allOperands[allOperands.length - 1];\n                        for (let i = allOperands.length - 2; i >= 0; i--) {\n                            const left = allOperands[i];\n                            const span = { start: left.span.start, end: result.span.end };\n                            result = AST.ExprNode.asBinary(span, left, '**', result);\n                        }\n\n                        return ParserLib.Result.createAsCustom('passed', 'power-expr', result, data.span);\n                    }\n                }\n            ),\n\n            ParserLib.createRule('MultiplicativeExpr',\n                ParserLib.seq(\n                    ParserLib.rule('PowerExpr'),\n                    ParserLib.zeroOrMore(\n                        ParserLib.seq(\n                            ParserLib.choice(\n                                ParserLib.token('*'),\n                                ParserLib.token('/'),\n                                ParserLib.token('%')\n                            ),\n                            ParserLib.rule('PowerExpr')\n                        )\n                    )\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        // ══════════ Extract Data ════════\n                        const seq_array = data.getSequenceResult()!;\n                        const base = seq_array[0];\n                        const operations = seq_array[1].getRepeatResult()!;\n\n                        if (operations.length === 0) { return base; }\n\n                        // ══════════ Build AST ══════════\n                        let result = base.getCustomData()! as AST.ExprNode;\n\n                        for (const op of operations) {\n                            const opSeq = op.getSequenceResult()!;\n                            const operator = opSeq[0].getChoiceResult()!.getTokenValue()!;\n                            const right = opSeq[1].getCustomData()! as AST.ExprNode;\n                            const span = { start: result.span.start, end: right.span.end };\n\n                            result = AST.ExprNode.asBinary(span, result, operator, right);\n                        }\n\n                        return ParserLib.Result.createAsCustom('passed', 'multiplicative-expr', result, data.span);\n                    }\n                }\n            ),\n\n            ParserLib.createRule('AdditiveExpr',\n                ParserLib.seq(\n                    ParserLib.rule('MultiplicativeExpr'),\n                    ParserLib.zeroOrMore(\n                        ParserLib.seq(\n                            ParserLib.choice(\n                                ParserLib.token('+'),\n                                ParserLib.token('-')\n                            ),\n                            ParserLib.rule('MultiplicativeExpr')\n                        )\n                    )\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        // ══════════ Extract Data ════════\n                        const seq_array = data.getSequenceResult()!;\n                        const base = seq_array[0];\n                        const operations = seq_array[1].getRepeatResult()!;\n\n                        if (operations.length === 0) { return base; }\n\n                        // ══════════ Build AST ══════════\n                        let result = base.getCustomData()! as AST.ExprNode;\n\n                        for (const op of operations) {\n                            const opSeq = op.getSequenceResult()!;\n                            const operator = opSeq[0].getChoiceResult()!.getTokenValue()!;\n                            const right = opSeq[1].getCustomData()! as AST.ExprNode;\n                            const span = { start: result.span.start, end: right.span.end };\n\n                            result = AST.ExprNode.asBinary(span, result, operator, right);\n                        }\n\n                        return ParserLib.Result.createAsCustom('passed', 'additive-expr', result, data.span);\n                    }\n                }\n            ),\n\n            ParserLib.createRule('ShiftExpr',\n                ParserLib.seq(\n                    ParserLib.rule('AdditiveExpr'),\n                    ParserLib.zeroOrMore(\n                        ParserLib.seq(\n                            ParserLib.choice(\n                                ParserLib.token('<<'),\n                                ParserLib.token('>>')\n                            ),\n                            ParserLib.rule('AdditiveExpr')\n                        )\n                    )\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        // ══════════ Extract Data ════════\n                        const seq_array = data.getSequenceResult()!;\n                        const base = seq_array[0];\n                        const operations = seq_array[1].getRepeatResult()!;\n\n                        if (operations.length === 0) { return base; }\n\n                        // ══════════ Build AST ══════════\n                        // Left-associative: a<<b<<c = (a<<b)<<c\n                        let result = base.getCustomData()! as AST.ExprNode;\n\n                        for (const op of operations) {\n                            const opSeq = op.getSequenceResult()!;\n                            const operator = opSeq[0].getChoiceResult()!.getTokenValue()!;\n                            const right = opSeq[1].getCustomData()! as AST.ExprNode;\n                            const span = { start: result.span.start, end: right.span.end };\n\n                            result = AST.ExprNode.asBinary(span, result, operator, right);\n                        }\n\n                        return ParserLib.Result.createAsCustom('passed', 'shift-expr', result, data.span);\n                    }\n                }\n            ),\n\n            ParserLib.createRule('RelationalExpr',\n                ParserLib.seq(\n                    ParserLib.rule('ShiftExpr'),\n                    ParserLib.zeroOrMore(\n                        ParserLib.seq(\n                            ParserLib.choice(\n                                ParserLib.token('<='),\n                                ParserLib.token('>='),\n                                ParserLib.token('<'),\n                                ParserLib.token('>')\n                            ),\n                            ParserLib.rule('ShiftExpr')\n                        )\n                    )\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        // ══════════ Extract Data ════════\n                        const seq_array = data.getSequenceResult()!;\n                        const base = seq_array[0];\n                        const operations = seq_array[1].getRepeatResult()!;\n\n                        if (operations.length === 0) { return base; }\n\n                        // ══════════ Build AST ══════════\n                        let result = base.getCustomData()! as AST.ExprNode;\n\n                        for (const op of operations) {\n                            const opSeq = op.getSequenceResult()!;\n                            const operator = opSeq[0].getChoiceResult()!.getTokenValue()!;\n                            const right = opSeq[1].getCustomData()! as AST.ExprNode;\n                            const span = { start: result.span.start, end: right.span.end };\n\n                            result = AST.ExprNode.asBinary(span, result, operator, right);\n                        }\n\n                        return ParserLib.Result.createAsCustom('passed', 'relational-expr', result, data.span);\n                    }\n                }\n            ),\n\n            ParserLib.createRule('EqualityExpr',\n                ParserLib.seq(\n                    ParserLib.rule('RelationalExpr'),\n                    ParserLib.zeroOrMore(\n                        ParserLib.seq(\n                            ParserLib.choice(\n                                ParserLib.token('=='),\n                                ParserLib.token('!=')\n                            ),\n                            ParserLib.rule('RelationalExpr')\n                        )\n                    )\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        // ══════════ Extract Data ════════\n                        const seq_array = data.getSequenceResult()!;\n                        const base = seq_array[0];\n                        const operations = seq_array[1].getRepeatResult()!;\n\n                        if (operations.length === 0) { return base; }\n\n                        // ══════════ Build AST ══════════\n                        let result = base.getCustomData()! as AST.ExprNode;\n\n                        for (const op of operations) {\n                            const opSeq = op.getSequenceResult()!;\n                            const operator = opSeq[0].getChoiceResult()!.getTokenValue()!;\n                            const right = opSeq[1].getCustomData()! as AST.ExprNode;\n                            const span = { start: result.span.start, end: right.span.end };\n\n                            result = AST.ExprNode.asBinary(span, result, operator, right);\n                        }\n\n                        return ParserLib.Result.createAsCustom('passed', 'equality-expr', result, data.span);\n                    }\n                }\n            ),\n\n            ParserLib.createRule('BitwiseAndExpr',\n                ParserLib.seq(\n                    ParserLib.rule('EqualityExpr'),\n                    ParserLib.zeroOrMore(\n                        ParserLib.seq(\n                            ParserLib.token('&'),\n                            ParserLib.rule('EqualityExpr')\n                        )\n                    )\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        // ══════════ Extract Data ════════\n                        const seq_array = data.getSequenceResult()!;\n                        const base = seq_array[0];\n                        const operations = seq_array[1].getRepeatResult()!;\n\n                        if (operations.length === 0) { return base; }\n\n                        // ══════════ Build AST ══════════\n                        let result = base.getCustomData()! as AST.ExprNode;\n\n                        for (const op of operations) {\n                            const opSeq = op.getSequenceResult()!;\n                            const right = opSeq[1].getCustomData()! as AST.ExprNode;\n                            const span = { start: result.span.start, end: right.span.end };\n\n                            result = AST.ExprNode.asBinary(span, result, '&', right);\n                        }\n\n                        return ParserLib.Result.createAsCustom('passed', 'bitwise-and-expr', result, data.span);\n                    }\n                }\n            ),\n\n            ParserLib.createRule('BitwiseXorExpr',\n                ParserLib.seq(\n                    ParserLib.rule('BitwiseAndExpr'),\n                    ParserLib.zeroOrMore(\n                        ParserLib.seq(\n                            ParserLib.token('^'),\n                            ParserLib.rule('BitwiseAndExpr')\n                        )\n                    )\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        // ══════════ Extract Data ════════\n                        const seq_array = data.getSequenceResult()!;\n                        const base = seq_array[0];\n                        const operations = seq_array[1].getRepeatResult()!;\n\n                        if (operations.length === 0) { return base; }\n\n                        // ══════════ Build AST ══════════\n                        let result = base.getCustomData()! as AST.ExprNode;\n\n                        for (const op of operations) {\n                            const opSeq = op.getSequenceResult()!;\n                            const right = opSeq[1].getCustomData()! as AST.ExprNode;\n                            const span = { start: result.span.start, end: right.span.end };\n\n                            result = AST.ExprNode.asBinary(span, result, '^', right);\n                        }\n\n                        return ParserLib.Result.createAsCustom('passed', 'bitwise-xor-expr', result, data.span);\n                    }\n                }\n            ),\n\n            ParserLib.createRule('BitwiseOrExpr',\n                ParserLib.seq(\n                    ParserLib.rule('BitwiseXorExpr'),\n                    ParserLib.zeroOrMore(\n                        ParserLib.seq(\n                            ParserLib.token('|'),\n                            ParserLib.rule('BitwiseXorExpr')\n                        )\n                    )\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        // ══════════ Extract Data ════════\n                        const seq_array = data.getSequenceResult()!;\n                        const base = seq_array[0];\n                        const operations = seq_array[1].getRepeatResult()!;\n\n                        if (operations.length === 0) { return base; }\n\n                        // ══════════ Build AST ══════════\n                        let result = base.getCustomData()! as AST.ExprNode;\n\n                        for (const op of operations) {\n                            const opSeq = op.getSequenceResult()!;\n                            const right = opSeq[1].getCustomData()! as AST.ExprNode;\n                            const span = { start: result.span.start, end: right.span.end };\n\n                            result = AST.ExprNode.asBinary(span, result, '|', right);\n                        }\n\n                        return ParserLib.Result.createAsCustom('passed', 'bitwise-or-expr', result, data.span);\n                    }\n                }\n            ),\n\n            ParserLib.createRule('LogicalAndExpr',\n                ParserLib.seq(\n                    ParserLib.rule('BitwiseOrExpr'),\n                    ParserLib.zeroOrMore(\n                        ParserLib.seq(\n                            ParserLib.token('and'),\n                            ParserLib.rule('BitwiseOrExpr')\n                        )\n                    )\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        // ══════════ Extract Data ════════\n                        const seq_array = data.getSequenceResult()!;\n                        const base = seq_array[0];\n                        const operations = seq_array[1].getRepeatResult()!;\n\n                        if (operations.length === 0) { return base; }\n\n                        // ══════════ Build AST ══════════\n                        // Left-associative: a and b and c = (a and b) and c\n                        let result = base.getCustomData()! as AST.ExprNode;\n\n                        for (const op of operations) {\n                            const opSeq = op.getSequenceResult()!;\n                            const right = opSeq[1].getCustomData()! as AST.ExprNode;\n                            const span = { start: result.span.start, end: right.span.end };\n\n                            result = AST.ExprNode.asBinary(span, result, 'and', right);\n                        }\n\n                        return ParserLib.Result.createAsCustom('passed', 'logical-and-expr', result, data.span);\n                    }\n                }\n            ),\n\n            ParserLib.createRule('LogicalOrExpr',\n                ParserLib.seq(\n                    ParserLib.rule('LogicalAndExpr'),\n                    ParserLib.zeroOrMore(\n                        ParserLib.seq(\n                            ParserLib.token('or'),\n                            ParserLib.rule('LogicalAndExpr')\n                        )\n                    )\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        // ══════════ Extract Data ════════\n                        const seq_array = data.getSequenceResult()!;\n                        const base = seq_array[0];\n                        const operations = seq_array[1].getRepeatResult()!;\n\n                        if (operations.length === 0) { return base; }\n\n                        // ══════════ Build AST ══════════\n                        // Left-associative: a or b or c = (a or b) or c\n                        let result = base.getCustomData()! as AST.ExprNode;\n\n                        for (const op of operations) {\n                            const opSeq = op.getSequenceResult()!;\n                            const right = opSeq[1].getCustomData()! as AST.ExprNode;\n                            const span = { start: result.span.start, end: right.span.end };\n\n                            result = AST.ExprNode.asBinary(span, result, 'or', right);\n                        }\n\n                        return ParserLib.Result.createAsCustom('passed', 'logical-or-expr', result, data.span);\n                    }\n                }\n            ),\n    ];\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// Stmt.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import * as ParserLib       from '@je-es/parser';\n    import * as AST             from '@je-es/ast';\n    import { ParseError }       from '@je-es/parser';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ INIT ════════════════════════════════════════╗\n\n    export const Stmt: ParserLib.Rules = [\n\n        // ════════════ ROOT ════════════\n\n            ParserLib.createRule('Stmt',\n                ParserLib.seq(\n                    ParserLib.choice(\n                        ParserLib.rule('BlockStmt'),\n                        ParserLib.rule('BreakStmt'),\n                        ParserLib.rule('ContinueStmt'),\n                        ParserLib.rule('FnStmt'),\n                        ParserLib.rule('LetStmt'),\n                        ParserLib.rule('UseStmt'),\n                        ParserLib.rule('DefStmt'),\n                        ParserLib.rule('WhileStmt'),\n                        ParserLib.rule('DoStmt'),\n                        ParserLib.rule('ForStmt'),\n                        ParserLib.rule('ReturnStmt'),\n                        ParserLib.rule('DeferStmt'),\n                        ParserLib.rule('ThrowStmt'),\n                        ParserLib.rule('TestStmt'),\n                        ParserLib.rule('Expr'),\n                    ),\n                    ParserLib.optional(\n                        ParserLib.token(';'),\n                    ),\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n\n                        // ══════════ Extract Data ════════\n\n                            const FUCKING_LENGTH_BEFORE_FUCKING_EXPR = 13;\n\n                            const seq_array     = data.getSequenceResult()!;\n                            const choise_ind    = seq_array[0].getChoiceIndex()!;\n                            const choise_res    = seq_array[0].getChoiceResult()!;\n                            const start_span    = data.span.start;\n                            const end_span      = seq_array[1].isOptionalPassed() ? seq_array[1].getOptionalResult()!.getTokenSpan()!.end : choise_res.span.end;\n                            const span          = {\n                                start: start_span,\n                                end: end_span,\n                            };\n\n                        // ══════ Syntax validation ══════\n\n                            // Syntax is internally validated,\n                            // but we may need to add more checks here to cover cases\n                            // not covered in the internal validations of each rule\n                            // because each rule assumes its own specific behavior.\n\n                        // ══════════ Build AST ══════════\n\n                            // Non-Expr\n                            if(choise_ind <= FUCKING_LENGTH_BEFORE_FUCKING_EXPR) {\n                                // fix span and return\n                                const stmt = choise_res.getCustomData()! as AST.StmtNode;\n\n                                if(stmt) {\n                                    stmt.span = span;\n                                    return ParserLib.Result.createAsCustom(choise_res.status, 'stmt', stmt, span);\n                                } else {\n                                    return choise_res;\n                                }\n\n                            }\n\n                            // Expr\n                            else {\n                                const expr = choise_res.getCustomData()! as AST.ExprNode;\n                                const stmt = AST.StmtNode.asExpr(span, expr);\n                                return ParserLib.Result.createAsCustom('passed', 'expr-stmt', stmt, span);\n                            }\n                    },\n                }\n            ),\n\n        // ════════════ ---- ════════════\n\n            ParserLib.createRule('FnStmt',\n                ParserLib.seq(\n                    // pub | static\n                    ParserLib.optional(ParserLib.choice(\n                        ParserLib.token('pub'),\n                        ParserLib.token('static')\n                    )),\n                    // comptime\n                    ParserLib.optional(ParserLib.token('comptime')),\n                    // inline\n                    ParserLib.optional(ParserLib.token('inline')),\n                    // fn <CatchPoint>\n                    ParserLib.token('fn'),\n                    // identifier\n                    ParserLib.optional(ParserLib.rule('Ident')),\n                    // (\n                    ParserLib.optional(ParserLib.token('(')),\n                    // parameters\n                    ParserLib.optional(\n                        ParserLib.oneOrMore(\n                            ParserLib.rule('Parameter'),\n                            ParserLib.token(','),\n                        ),\n                    ),\n                    // )\n                    ParserLib.optional(ParserLib.token(')')),\n\n                    ParserLib.optional(ParserLib.token('->')),\n\n                    // error type can be : ident(MyError) or access(MySet.MyError) and later `errset { A, B }`\n                    ParserLib.optional(ParserLib.rule('Type')),\n                    ParserLib.optional(ParserLib.token('!')),\n                    ParserLib.optional(ParserLib.rule('Type')),\n\n                    // body (can be stmt or block of stmts)\n                    ParserLib.optional(ParserLib.rule('Stmt')),\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n\n                        // ══════════ Extract Data ════════\n\n                            const seq_array         = data.getSequenceResult()!;\n\n                            const isAttr            = seq_array[0].isOptionalPassed();\n                            const isPublic          = isAttr && seq_array[0].getOptionalResult()!.getChoiceIndex() === 0;\n                            const isStatic          = isAttr && seq_array[0].getOptionalResult()!.getChoiceIndex() === 1;\n                            const isComptime        = seq_array[1].isOptionalPassed();\n                            const isInline          = seq_array[2].isOptionalPassed();\n                            const isIdent           = seq_array[4].isOptionalPassed();\n                            const isOpeningParen    = seq_array[5].isOptionalPassed();\n                            const isParams          = seq_array[6].isOptionalPassed();\n                            const isClosingParen    = seq_array[7].isOptionalPassed();\n                            const isArrowSign       = seq_array[8].isOptionalPassed();\n                            const isErrorType       = seq_array[9].isOptionalPassed();\n                            const isNotSign         = seq_array[10].isOptionalPassed();\n                            const isReturnType      = seq_array[11].isOptionalPassed();\n                            const isBody            = seq_array[12].isOptionalPassed();\n\n                            const visibilitySpan    = isAttr         ? seq_array[0].span : undefined;\n                            const comptimeSpan      = isComptime     ? seq_array[1].span : undefined;\n                            const fnSpan            = seq_array[3].getTokenSpan()!;\n                            const openingParenSpan  = isOpeningParen ? seq_array[5].span : undefined;\n                            const closingParenSpan  = isClosingParen ? seq_array[7].span : undefined;\n                            const arrowSignSpan     = isArrowSign    ? seq_array[8].span : undefined;\n                            const notSignSpan       = isNotSign      ? seq_array[10].span : undefined;\n\n                            let ident       = isIdent       ? seq_array[ 4].getOptionalResult()!.getCustomData()! as AST.IdentNode  : undefined;\n                            let parameters  = [] as AST.FieldNode[];\n                            let errorType   = isErrorType   ? seq_array[ 9].getOptionalResult()!.getCustomData()! as AST.TypeNode   : undefined;\n                            let returnType  = isReturnType  ? seq_array[11].getOptionalResult()!.getCustomData()! as AST.TypeNode   : undefined;\n                            let body        = isBody        ? seq_array[12].getOptionalResult()!.getCustomData()! as AST.StmtNode   : undefined;\n\n                            if (isParams) {\n                                const paramList = seq_array[6].getOptionalResult()!.getRepeatResult()!;\n                                parameters = paramList.map(r => r.getCustomData()! as AST.FieldNode);\n                            }\n\n                            // if we have an error type, but no return type and no not sign, then the error type is the return type\n                            if(errorType && !returnType && !isNotSign) {\n                                // if the error type is not an error type or an ident, then it is the return type\n                                if(!errorType!.isErrset() && !isNotSign) {\n                                    returnType = errorType;\n                                    errorType = undefined;\n                                }\n                            }\n\n                            // default error type\n                            if(isNotSign && !errorType) {\n                                errorType = AST.TypeNode.asErr();\n                            }\n\n                            let lastElemSpan = data.span;\n                            {\n                                if(isBody) {\n                                    lastElemSpan = body!.span;\n                                } else if(returnType) {\n                                    lastElemSpan = returnType.span;\n                                } else if(isNotSign) {\n                                    lastElemSpan = notSignSpan!;\n                                } else if(errorType) {\n                                    lastElemSpan = errorType.span;\n                                } else if(isArrowSign) {\n                                    lastElemSpan = arrowSignSpan!;\n                                } else if(isClosingParen) {\n                                    lastElemSpan = closingParenSpan!;\n                                } else if(isParams && parameters.length) {\n                                    lastElemSpan = parameters[parameters.length-1].span;\n                                } else if(isOpeningParen) {\n                                    lastElemSpan = openingParenSpan!;\n                                } else if(isIdent) {\n                                    lastElemSpan = ident!.span;\n                                } else {\n                                    lastElemSpan = fnSpan;\n                                }\n                            }\n\n                        // ══════ Syntax validation ══════\n\n                            // Missing identifier\n                            if (!ident) {\n                                throw {\n                                    msg: \"Expected identifier after `fn` keyword\",\n                                    span: fnSpan,\n                                } as ParseError;\n                            }\n\n                            // Missing opening parenthesis\n                            if (!isOpeningParen) {\n                                throw {\n                                    msg: \"Expected `(` after function name\",\n                                    span: ident.span,\n                                } as ParseError;\n                            }\n\n                            // Missing closing parenthesis\n                            if (!isClosingParen) {\n                                throw {\n                                    msg: isParams && parameters.length\n                                            ? \"Expected `)` after parameters\"\n                                            : \"Expected parameters or `)` after `(`\",\n                                    span: isParams && parameters.length\n                                            ? { start: openingParenSpan!.start, end: parameters[parameters.length-1].span.end }\n                                            : openingParenSpan\n                                } as ParseError;\n                            }\n\n                            // Return type arrow without type\n                            if (isArrowSign && !returnType) {\n                                throw {\n                                    msg: \"Expected return type after `->`\",\n                                    span: arrowSignSpan,\n                                } as ParseError;\n                            }\n\n                            // Return type without arrow\n                            if (!isArrowSign && returnType) {\n                                throw {\n                                    msg: \"Expected `->` before return type\",\n                                    span: returnType.span,\n                                } as ParseError;\n                            }\n\n                            // Error type without `!`\n                            if (errorType && !isNotSign) {\n                                throw {\n                                    msg: \"Expected `!` after error type\",\n                                    span: errorType.span,\n                                } as ParseError;\n                            }\n\n                            // will never happend after this update.\n                            // // `!` without error type\n                            // if (!errorType && isNotSign) {\n                            //     throw {\n                            //         msg: \"Expected error type before `!`\",\n                            //         span: notSignSpan,\n                            //     } as ParseError;\n                            // }\n\n                            // Invalid Error type\n                            if(errorType && !errorType!.isErrset() && !errorType!.isErr() && !errorType!.isIdent()) {\n                                throw {\n                                    msg: \"Error type must be error name or error set\",\n                                    span: errorType!.span,\n                                } as ParseError;\n                            }\n\n                            // Missing body\n                            if (!body) {\n                                // throw new Error(\"Expected function body\");\n                                throw {\n                                    msg: \"Expected function body\",\n                                    span: {\n                                        start: lastElemSpan.end,\n                                        end: lastElemSpan.end + 1,\n                                    },\n                                } as ParseError;\n                            }\n\n                        // ══════════ Build AST ══════════\n\n                            const result = AST.StmtNode.asFunc(\n                                data.span,\n                                {\n                                    kind: isPublic ? 'Public' : isStatic ? 'Static' : 'Private',\n                                    span: visibilitySpan,\n                                },\n                                {\n                                    kind: isComptime ? 'Comptime' : 'Runtime',\n                                    span: comptimeSpan,\n                                },\n                                isInline,\n                                ident,\n                                parameters,\n                                errorType,\n                                returnType,\n                                body\n                            );\n\n                            return ParserLib.Result.createAsCustom('passed', 'function-stmt', result, data.span);\n                    },\n                    errors: [\n                        ParserLib.error(1, 'Expected `fn` keyword'),\n                    ]\n                }\n            ),\n\n            ParserLib.createRule('UseStmt',\n                ParserLib.seq(\n                    // pub | static\n                    ParserLib.optional(ParserLib.choice(\n                        ParserLib.token('pub'),\n                        ParserLib.token('static')\n                    )),\n                    // use  <CatchPoint>\n                    ParserLib.token('use'),\n                    // target\n                    ParserLib.optional(\n                        ParserLib.choice(\n                            ParserLib.token('*'),\n                            ParserLib.oneOrMore(\n                                ParserLib.rule('Ident'),\n                                ParserLib.token('.'),\n                            ),\n                        )\n                    ),\n                    // as\n                    ParserLib.optional(ParserLib.token('as')),\n                    // alias\n                    ParserLib.optional(\n                        ParserLib.choice(\n                            ParserLib.rule('Ident'),    // allow\n                            ParserLib.rule('Stmt'),     // reject\n                        )\n                    ),\n                    // from\n                    ParserLib.optional(ParserLib.token('from')),\n                    // path\n                    ParserLib.optional(ParserLib.token('slice')),\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n\n                        // ══════════ Extract Data ════════\n\n                            const seq_array = data.getSequenceResult()!;\n\n                            // visibility\n                            const isVisibility      = seq_array[0].isOptionalPassed();\n                            const isPublic          = isVisibility && seq_array[0].getOptionalResult()!.getChoiceIndex() === 0;\n                            const isStatic          = isVisibility && seq_array[0].getOptionalResult()!.getChoiceIndex() === 1;\n\n                            const isAs              = seq_array[3].isOptionalPassed();\n                            const isAlias           = seq_array[4].isOptionalPassed();\n                            const isAliasIdent      = isAlias && seq_array[4].getOptionalResult()!.getChoiceIndex() === 0;\n                            const isFrom            = seq_array[5].isOptionalPassed();\n                            const isPath            = seq_array[6].isOptionalPassed();\n\n                            const useSpan           = seq_array[1].span;\n                            const asSpan            = isAs     ? seq_array[3].span : undefined;\n                            const aliasSpan         = isAlias  ? seq_array[4].span : undefined;\n                            const fromSpan          = isFrom   ? seq_array[5].span : undefined;\n                            const pathSpan          = isPath   ? seq_array[6].span : undefined;\n                            const visibilitySpan    = isVisibility ? seq_array[0].span : undefined;\n\n                            // Target\n                            const isTargetPassed        = seq_array[2].isOptionalPassed()!;\n                            const isTargetNotButNotAll  = isTargetPassed && seq_array[2].getOptionalResult()!.getChoiceIndex()! !== 0;\n\n                            const targetKind        : 'ident' | 'access' | 'all' | undefined\n                                                    =\n                                                    isTargetPassed\n                                                    ? !isTargetNotButNotAll\n                                                        ? 'all'\n                                                        : seq_array[2].getOptionalResult()!.getChoiceResult()!.getRepeatCount()! === 1\n                                                            ? 'ident'\n                                                            : 'access'\n                                                    : undefined;\n\n                            const isTarget          = targetKind === 'ident' || targetKind === 'access' &&\n                                                      seq_array[2].getOptionalResult()!.getChoiceResult()!.getRepeatCount()! > 0;\n\n                            let targetArr           = targetKind === 'ident' || targetKind === 'access'\n                                                    ? seq_array[2].getOptionalResult()!.getChoiceResult()!.getRepeatResult()!.map(x => x.getCustomData()! as AST.IdentNode)\n                                                    : undefined;\n\n                            // Is end with dot ?\n                            const isEndWithDot      = isTargetNotButNotAll && seq_array[2].getOptionalResult()!.getChoiceResult()!.isRepeatEndsWithSep();\n\n                            // full span\n                            const targetArrSpan     = targetKind === 'ident' || targetKind === 'access' && targetArr!.length ?\n                            {\n                                start: targetArr![0].span.start,\n                                end: isEndWithDot ? targetArr![targetArr!.length-1].span.end+1 : targetArr![targetArr!.length-1].span.end,\n                            } : undefined;\n\n                            // handle alias\n                            let alias       = isAliasIdent ? (seq_array[4].getOptionalResult()!.getChoiceResult()!.getCustomData()! as AST.IdentNode) : undefined;\n\n                            // handle path\n                            let path        = isPath ? seq_array[6].getOptionalResult()!.getTokenData()!.value ?? \"\"      : undefined;\n\n                        // ══════ Syntax validation ══════\n\n                            // Missing target\n                            if(targetKind === undefined) {\n                                throw {\n                                    msg: \"Expected identifier after `use` keyword\",\n                                    span: useSpan,\n                                } as ParseError;\n                            }\n\n                            // ends with .\n                            if(isEndWithDot) {\n                                throw {\n                                    msg: \"Expected identifier after `.` in target\",\n                                    span: targetArrSpan,\n                                } as ParseError;\n                            }\n\n                            // If 'from' is present, path must be present\n                            if(isFrom && !isPath) {\n                                throw {\n                                    msg: \"Expected module path after `from` keyword\",\n                                    span: fromSpan\n                                } as ParseError;\n                            }\n\n                            // If 'from' is not present, path must not be present\n                            if(!isFrom && isPath) {\n                                throw {\n                                    msg: \"Expected `from` keyword before module path\",\n                                    span: pathSpan\n                                } as ParseError;\n                            }\n\n                            // Check for empty path string\n                            if (path === \"\") {\n                                throw {\n                                    msg: \"Module path cannot be empty\",\n                                    span: pathSpan!\n                                } as ParseError;\n                            }\n\n                            // Missing alias\n                            if(isAs && !isAlias) {\n                                throw {\n                                    msg: \"Expected identifier after `as` keyword\",\n                                    span: asSpan\n                                } as ParseError;\n                            }\n\n                            // Invalid alias\n                            if(!isAliasIdent && isAlias && isAs) {\n                                throw {\n                                    msg: \"Alias must be an identifier\",\n                                    span: aliasSpan,\n                                } as ParseError;\n                            }\n\n                            // Missing As\n                            if(isTarget && isAlias && !isAs) {\n                                throw {\n                                    msg: \"Expected `as` keyword after alias\",\n                                    span: aliasSpan\n                                } as ParseError;\n                            }\n\n                            // Error: 'use x;' (no from clause, no alias) is not allowed\n                            if (!alias && !path) {\n                                throw {\n                                    msg: \"Must specify either an alias or a module path\",\n                                    span: targetArrSpan!\n                                } as ParseError;\n                            }\n\n                        // ══════════ Build AST ══════════\n\n                            const result = AST.StmtNode.asUse(\n                                data.span,\n                                {\n                                    kind: isPublic ? 'Public' : isStatic ? 'Static' : 'Private',\n                                    span: visibilitySpan,\n                                },\n                                targetKind === 'all' ? undefined : targetArr!,\n                                alias,\n                                path,\n                                pathSpan\n                            );\n                            return ParserLib.Result.createAsCustom('passed', 'use-stmt', result, data.span);\n                    },\n                }\n            ),\n\n            ParserLib.createRule('DefStmt',\n                ParserLib.seq(\n                    // pub | static\n                    ParserLib.optional(ParserLib.choice(\n                        ParserLib.token('pub'),\n                        ParserLib.token('static')\n                    )),\n                    // def <CatchPoint>\n                    ParserLib.token(`def`),\n                    // ident\n                    ParserLib.optional(ParserLib.rule('Ident')),\n                    // =\n                    ParserLib.optional(ParserLib.token(`=`)),\n                    // type\n                    ParserLib.optional(ParserLib.rule('Type')),\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n\n                        // ══════════ Extract Data ════════\n\n                            const seq_array         = data.getSequenceResult()!;\n\n                            const isAttr            = seq_array[0].isOptionalPassed();\n                            const isPublic          = isAttr && seq_array[0].getOptionalResult()!.getChoiceIndex() === 0;\n                            const isStatic          = isAttr && seq_array[0].getOptionalResult()!.getChoiceIndex() === 1;\n                            const isIdent           = seq_array[2].isOptionalPassed();\n                            const isEqualSign       = seq_array[3].isOptionalPassed();\n                            const isType            = seq_array[4].isOptionalPassed();\n\n                            let ident               = isIdent ? seq_array[2].getOptionalResult()!.getCustomData()! as AST.IdentNode : undefined;\n                            let type                = isType ? seq_array[4].getOptionalResult()!.getCustomData()! as AST.TypeNode : undefined;\n\n                            const defSpan           = seq_array[1].span;\n                            const equalSignSpan     = seq_array[3].span;\n                            const visibilitySpan    = isAttr ? seq_array[0].span : undefined;\n\n                        // ══════ Syntax validation ══════\n\n                            if(!isIdent) {\n                                throw {\n                                    msg: \"Expected identifier after `def` keyword\",\n                                    span: defSpan,\n                                }\n                            }\n\n                            // type without `=`\n                            if(type && !isEqualSign) {\n                                // throw new Error(\"Expected `=` before type\");\n                                throw {\n                                    msg: \"Expected `=` before type\",\n                                    span: { start: type.span.start - 1, end: type.span.start, },\n                                } as ParseError\n                            }\n\n                            // `=` without type\n                            if(!type && isEqualSign) {\n                                throw {\n                                    msg: \"Expected type after `=`\",\n                                    span: equalSignSpan,\n                                } as ParseError\n                            }\n\n                            // if no :type and not =expr so reject\n                            if(!type) {\n                                throw {\n                                    msg: `Missing type`,\n                                    span: defSpan,\n                                } as ParseError\n                            }\n\n                        // ══════════ Build AST ══════════\n\n                            if(type.isStruct()) type.getStruct()!.name = ident!.name;\n\n                            return ParserLib.Result.createAsCustom( 'passed', 'def-stmt',\n                                AST.StmtNode.asDefine(\n                                    data.span,\n                                    {\n                                        kind: isPublic ? 'Public' : isStatic ? 'Static' : 'Private',\n                                        span: visibilitySpan,\n                                    },\n                                    ident!,\n                                    type!,\n                                ),\n                                data.span\n                            );\n                    }\n                }\n            ),\n\n            ParserLib.createRule('BlockStmt',\n                ParserLib.seq(\n                    ParserLib.token('{'),\n                    ParserLib.zeroOrMore(ParserLib.rule('Stmt')),\n                    ParserLib.token('}'),\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n\n                        // ══════════ Extract Data ════════\n\n                            const seq_array     = data.getSequenceResult()!;\n                            const span          = { start: seq_array[0].getTokenSpan()!.start, end: seq_array[2].getTokenSpan()!.end };\n                            const stmtsCount    = seq_array[1].getRepeatCount()!;\n                            const stmts         = stmtsCount > 0\n                                                ? seq_array[1].getRepeatResult()!.map((x) => x.getCustomData()! as AST.StmtNode)\n                                                : [];\n\n                        // ══════════ Build AST ══════════\n\n                            const result = AST.StmtNode.asBlock(span, stmts);\n                            return ParserLib.Result.createAsCustom('passed', 'block-stmt', result, span);\n                    },\n                }\n            ),\n\n            ParserLib.createRule('TestStmt',\n                ParserLib.seq(\n                    ParserLib.token('test'),\n                    ParserLib.optional(ParserLib.token('slice')),\n                    ParserLib.optional(ParserLib.rule('BlockStmt')),\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n\n                        // ══════════ Extract Data ════════\n\n                            const seq_array     = data.getSequenceResult()!;\n\n                            const isNamePassed  = seq_array[1].isOptionalPassed();\n                            const isBlockPassed = seq_array[2].isOptionalPassed();\n\n                            const nameToken     = isNamePassed ? seq_array[1].getOptionalResult()!.getTokenData()! : undefined;\n                            const blockStmt     = isBlockPassed ? seq_array[2].getOptionalResult()!.getCustomData()! as AST.StmtNode : undefined;\n\n                            const testSpan      = seq_array[0].span;\n\n                        // ══════════ Syntax validation ══════════\n\n                            // Missing block\n                            if(!isBlockPassed) {\n                                if(isNamePassed) {\n                                    throw {\n                                        msg: \"Expected block statement after test name\",\n                                        span: nameToken!.span,\n                                    } as ParseError;\n                                } else {\n                                    throw {\n                                        msg: \"Expected block statement or test name after `test` keyword\",\n                                        span: testSpan,\n                                    } as ParseError;\n                                }\n                            }\n\n                        // ══════════ Build AST ══════════\n\n                            const nameInfo = isNamePassed ? {\n                                name: nameToken!.value!,\n                                span: nameToken!.span,\n                            } : undefined;\n                            const result = AST.StmtNode.asTest(data.span, nameInfo, blockStmt!.getBlock()!);\n                            return ParserLib.Result.createAsCustom('passed', 'test-stmt', result, data.span);\n                    },\n                }\n            ),\n\n        // ════════════ ---- ════════════\n\n            ParserLib.createRule('WhileStmt',\n                ParserLib.seq(\n                    // while <Catchpoint>\n                    ParserLib.token('while'),\n                    // expr\n                    ParserLib.optional(ParserLib.rule('Expr')),\n                    // stmt\n                    ParserLib.optional(ParserLib.rule('Stmt'))\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n\n                        // ══════════ Extract Data ════════\n\n                            const seq_array         = data.getSequenceResult()!;\n\n                            const isExpr            = seq_array[1].isOptionalPassed();\n                            const isStmt            = seq_array[2].isOptionalPassed();\n\n                            const expr              = isExpr ? seq_array[1].getOptionalResult()!.getCustomData()! as AST.ExprNode : undefined;\n                            const stmt              = isStmt ? seq_array[2].getOptionalResult()!.getCustomData()! as AST.StmtNode : undefined;\n\n                            const whileSpan         = seq_array[0].span;\n\n                        // ══════════ Syntax validation ══════════\n\n                            // Missing expression\n                            if(!isExpr) {\n                                throw {\n                                    msg: \"Expected expression after `while` keyword\",\n                                    span: whileSpan,\n                                } as ParseError;\n                            }\n\n                            // Missing statement\n                            if(!isStmt) {\n                                throw {\n                                    msg: \"Expected statement after expression\",\n                                    span: expr!.span,\n                                } as ParseError;\n                            }\n\n                        // ═══════════ Build AST ══════════\n\n                            const result = AST.StmtNode.asWhile(data.span, expr!, stmt!);\n                            return ParserLib.Result.createAsCustom('passed', 'while-stmt', result, data.span);\n                    },\n                }\n            ),\n\n            ParserLib.createRule('DoStmt',\n                ParserLib.seq(\n                    // do <Catchpoint>\n                    ParserLib.token('do'),\n                    // stmt\n                    ParserLib.optional(ParserLib.rule('Stmt')),\n                    // while <Catchpoint>\n                    ParserLib.optional(ParserLib.token('while')),\n                    // expression\n                    ParserLib.optional(ParserLib.rule('Expr'))\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n\n                        // ══════════ Extract Data ════════\n\n                            const seq_array         = data.getSequenceResult()!;\n\n                            const isStmt            = seq_array[1].isOptionalPassed();\n                            const isWhile           = seq_array[2].isOptionalPassed();\n                            const isExpr            = seq_array[3].isOptionalPassed();\n\n                            const stmt              = isStmt ? seq_array[1].getOptionalResult()!.getCustomData()! as AST.StmtNode : undefined;\n                            const expr              = isExpr ? seq_array[3].getOptionalResult()!.getCustomData()! as AST.ExprNode : undefined;\n\n                            const doSpan           = seq_array[0].span;\n                            const whileSpan        = isWhile ? seq_array[2].span : undefined;\n\n                        // ══════════ Syntax validation ══════════\n\n                            // Missing statement\n                            if(!isStmt) {\n                                throw {\n                                    msg: \"Expected statement after `do` keyword\",\n                                    span: doSpan,\n                                } as ParseError;\n                            }\n\n                            // Missing while keyword\n                            if(!isWhile) {\n                                throw {\n                                    msg: \"Expected `while` keyword after statement\",\n                                    span: stmt!.span,\n                                } as ParseError;\n                            }\n\n                            // Missing expression\n                            if(!isExpr) {\n                                throw {\n                                    msg: \"Expected expression after `while` keyword\",\n                                    span: whileSpan,\n                                } as ParseError;\n                            }\n\n                        // ═══════════ Build AST ══════════\n\n                            const result = AST.StmtNode.asDo(data.span, expr!, stmt!);\n                            return ParserLib.Result.createAsCustom('passed', 'do-stmt', result, data.span);\n                    },\n                }\n            ),\n\n            ParserLib.createRule('ForStmt',\n                ParserLib.seq(\n                    // for <Catchpoint>\n                    ParserLib.token('for'),\n                    // expr\n                    ParserLib.optional(ParserLib.rule('Expr')),\n                    // stmt\n                    ParserLib.optional(ParserLib.rule('Stmt'))\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n\n                        // ══════════ Extract Data ════════\n\n                            const seq_array         = data.getSequenceResult()!;\n\n                            const isExpr            = seq_array[1].isOptionalPassed();\n                            const isStmt            = seq_array[2].isOptionalPassed();\n\n                            const expr              = isExpr ? seq_array[1].getOptionalResult()!.getCustomData()! as AST.ExprNode : undefined;\n                            const stmt              = isStmt ? seq_array[2].getOptionalResult()!.getCustomData()! as AST.StmtNode : undefined;\n\n                            const forSpan         = seq_array[0].span;\n\n                        // ══════════ Syntax validation ══════════\n\n                            // Missing expression\n                            if(!isExpr) {\n                                throw {\n                                    msg: \"Expected range expression after `for` keyword\",\n                                    span: forSpan,\n                                } as ParseError;\n                            }\n\n                            // Invalid expression type (must be range type)\n                            if(!expr!.isOrEndWith('Range')) {\n                                throw {\n                                    msg: \"Expected range expression after `for` keyword\",\n                                    span: expr!.span,\n                                } as ParseError;\n                            }\n\n                            // Missing statement\n                            if(!isStmt) {\n                                throw {\n                                    msg: \"Expected statement after range expression\",\n                                    span: expr!.span,\n                                } as ParseError;\n                            }\n\n                        // ═══════════ Build AST ══════════\n\n                            const result = AST.StmtNode.asFor(data.span, expr!, stmt!);\n                            return ParserLib.Result.createAsCustom('passed', 'for-stmt', result, data.span);\n                    },\n                }\n            ),\n\n            ParserLib.createRule('ReturnStmt',\n                ParserLib.seq(\n                    // return <Catchpoint>\n                    ParserLib.token('return'),\n                    // expr\n                    ParserLib.optional(ParserLib.rule('Expr'))\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n\n                        // ══════════ Extract Data ════════\n\n                            const seq_array         = data.getSequenceResult()!;\n                            const isExpr            = seq_array[1].isOptionalPassed();\n                            const expr              = isExpr ? seq_array[1].getOptionalResult()!.getCustomData()! as AST.ExprNode : undefined;\n\n                        // ═══════════ Build AST ══════════\n\n                            const result = AST.StmtNode.asReturn(data.span, expr);\n                            return ParserLib.Result.createAsCustom('passed', 'return-stmt', result, data.span);\n                    }\n                }\n            ),\n\n            ParserLib.createRule('DeferStmt',\n                ParserLib.seq(\n                    // defer <Catchpoint>\n                    ParserLib.token('defer'),\n                    // expr\n                    ParserLib.optional(ParserLib.rule('Expr'))\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n\n                        // ══════════ Extract Data ════════\n\n                            const seq_array         = data.getSequenceResult()!;\n                            const isExpr            = seq_array[1].isOptionalPassed();\n                            const expr              = isExpr ? seq_array[1].getOptionalResult()!.getCustomData()! as AST.ExprNode : undefined;\n\n                            const deferSpan         = seq_array[0].span;\n\n                        // ══════════ Syntax validation ══════════\n\n                            // Missing expression\n                            if(!isExpr) {\n                                throw {\n                                    msg: \"Expected expression after `defer` keyword\",\n                                    span: deferSpan,\n                                } as ParseError;\n                            }\n\n                        // ═══════════ Build AST ══════════\n\n                            const result = AST.StmtNode.asDefer(data.span, expr);\n                            return ParserLib.Result.createAsCustom('passed', 'defer-stmt', result, data.span);\n                    }\n                }\n            ),\n\n            ParserLib.createRule('ThrowStmt',\n                ParserLib.seq(\n                    // throw <Catchpoint>\n                    ParserLib.token('throw'),\n                    // expr\n                    ParserLib.optional(ParserLib.rule('Expr'))\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n\n                        // ══════════ Extract Data ════════\n\n                            const seq_array         = data.getSequenceResult()!;\n                            const isExpr            = seq_array[1].isOptionalPassed();\n                            const expr              = isExpr ? seq_array[1].getOptionalResult()!.getCustomData()! as AST.ExprNode : undefined;\n\n                            const throwSpan         = seq_array[0].span;\n\n                        // ══════════ Syntax validation ══════════\n\n                            // Missing expression\n                            if(!isExpr) {\n                                throw {\n                                    msg: \"Expected expression after `throw` keyword\",\n                                    span: throwSpan,\n                                } as ParseError;\n                            }\n\n                        // ═══════════ Build AST ══════════\n\n                            const result = AST.StmtNode.asThrow(data.span, expr);\n                            return ParserLib.Result.createAsCustom('passed', 'throw-stmt', result, data.span);\n                    }\n                }\n            ),\n\n            ParserLib.createRule('BreakStmt',\n                // break <Catchpoint>\n                ParserLib.token('break'),\n                {\n                    build: (data: ParserLib.Result) => {\n\n                        // ══════════ Extract Data ════════\n\n                            const breakSpan = data.span;\n\n                        // ═══════════ Build AST ══════════\n\n                            const result = AST.StmtNode.asBreak(breakSpan);\n                            return ParserLib.Result.createAsCustom('passed', 'break-stmt', result, data.span);\n                    }\n                }\n            ),\n\n            ParserLib.createRule('ContinueStmt',\n                // continue <Catchpoint>\n                ParserLib.token('continue'),\n                {\n                    build: (data: ParserLib.Result) => {\n\n                        // ══════════ Extract Data ════════\n\n                            const continueSpan = data.span;\n\n                        // ═══════════ Build AST ══════════\n\n                            const result = AST.StmtNode.asContinue(continueSpan);\n                            return ParserLib.Result.createAsCustom('passed', 'continue-stmt', result, data.span);\n                    }\n                }\n            ),\n\n        // ════════════ ---- ════════════\n\n            // one builder for ( variables / function parameters / structure fields)\n            createCommonVariableRule('LetStmt'),\n            createCommonVariableRule('Parameter'),\n            createCommonVariableRule('StructField'),\n\n        // ════════════ ---- ════════════\n\n    ];\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ HELP ════════════════════════════════════════╗\n\n    // one builder for ( variables / function parameters / structure fields)\n    type commonVariableKind = 'LetStmt' | 'Parameter' | 'StructField';\n    function createCommonVariableRule(kind: commonVariableKind) {\n        return ParserLib.createRule(kind,\n            ParserLib.seq(\n                // pub | static\n                ParserLib.optional(ParserLib.choice(\n                    ParserLib.token('pub'),\n                    ParserLib.token('static')\n                )),\n                // comptime\n                ParserLib.optional(ParserLib.token('comptime')),\n                // let <CatchPoint> if Variable\n                kind === 'LetStmt' ? ParserLib.token(`let`) : ParserLib.optional(ParserLib.token('let')),\n                // mut\n                ParserLib.optional(ParserLib.token('mut')),\n                // ident  <CatchPoint> if not Variable\n                kind === 'LetStmt' ? ParserLib.optional(ParserLib.rule('Ident')) : ParserLib.rule('Ident'),\n                // :\n                ParserLib.optional(ParserLib.token(`:`)),\n                // type\n                ParserLib.optional(ParserLib.rule('Type')),\n                // =\n                ParserLib.optional(ParserLib.token(`=`)),\n                // expr\n                ParserLib.optional(ParserLib.rule('Expr')),\n            ),\n            {\n                build: (data: ParserLib.Result) => {\n\n                    // ══════════ Extract Data ════════\n\n                        const catchPoint : 'let' | 'ident' = kind === 'LetStmt' ? 'let' : 'ident';\n\n                        const seq_array         = data.getSequenceResult()!;\n\n                        const isAttr            = seq_array[0].isOptionalPassed();\n                        const isPublic          = isAttr && seq_array[0].getOptionalResult()!.getChoiceIndex() === 0;\n                        const isStatic          = isAttr && seq_array[0].getOptionalResult()!.getChoiceIndex() === 1;\n                        const isComptime        = seq_array[1].isOptionalPassed();\n                        const isLet             = catchPoint === 'let' ? true : seq_array[2].isOptionalPassed();\n                        const isMutable         = seq_array[3].isOptionalPassed();\n                        const isIdent           = catchPoint === 'ident' ? true : seq_array[4].isOptionalPassed();\n                        const isColonSign       = seq_array[5].isOptionalPassed();\n                        const isType            = seq_array[6].isOptionalPassed();\n                        const isEqualSign       = seq_array[7].isOptionalPassed();\n                        const isInitializer     = seq_array[8].isOptionalPassed();\n\n                        let ident               = catchPoint === 'let' && isIdent\n                                                 ? seq_array[4].getOptionalResult()!.getCustomData()! as AST.IdentNode\n                                                 : catchPoint === 'ident' && isIdent\n                                                 ? seq_array[4].getCustomData()! as AST.IdentNode\n                                                 : undefined;\n\n                        let type                = isType        ? seq_array[ 6].getOptionalResult()!.getCustomData()! as AST.TypeNode   : undefined;\n                        let initializer         = isInitializer ? seq_array[ 8].getOptionalResult()!.getCustomData()! as AST.ExprNode   : undefined;\n\n                        const visibilitySpan    = isAttr      ? seq_array[0].span : undefined;\n                        const comptimeSpan      = isComptime  ? seq_array[1].span : undefined;\n                        const letSpan           = catchPoint === 'let' ? seq_array[2].span : isLet ? seq_array[2].span : undefined;\n                        const mutSpan           = isMutable   ? seq_array[3].span : undefined;\n                        const colonSignSpan     = isColonSign ? seq_array[5].span : undefined;\n                        const equalSignSpan     = isEqualSign ? seq_array[7].span : undefined;\n\n                    // ══════ Syntax validation ══════\n\n                        // static/Pub keywords now allowed with params\n                        if(isAttr && kind === 'Parameter') {\n                            if(isPublic) {\n                                throw {\n                                    msg     : \"`pub` keyword is not allowed in this context\",\n                                    span    : visibilitySpan!,\n                                } as ParseError\n                            } else if(isStatic) {\n                                throw {\n                                    msg     : \"`static` keyword is not allowed in this context\",\n                                    span    : visibilitySpan!,\n                                } as ParseError\n                            }\n                        }\n\n                        // Missing identifier (if not let stmt)\n                        if(!ident && catchPoint === 'let') {\n                            throw {\n                                msg     : mutSpan\n                                        ? \"Expected identifier after `mut` keyword\"\n                                        : \"Expected identifier after `let` keyword\",\n                                span    : mutSpan ?? letSpan,\n                            } as ParseError\n                        }\n\n                        if(!ident) {\n                            throw new Error(\"unreachable code detected\")\n                        }\n\n                        // let keyword not-allowed in this context (if not let stmt)\n                        if(isLet && catchPoint !== 'let') {\n                            throw {\n                                msg     : \"`let` keyword is not allowed in this context\",\n                                span    : letSpan!,\n                            } as ParseError\n                        }\n\n                        // Type without `:`\n                        if(type && !isColonSign) {\n                            throw {\n                                msg: \"Expected `:` before type\",\n                                span: type.span,\n                            } as ParseError\n                        }\n\n                        // `:` without type\n                        if(!type && isColonSign) {\n                            throw {\n                                msg: \"Expected type after `:`\",\n                                span: colonSignSpan,\n                            } as ParseError\n                        }\n\n                        // Initializer without `=`\n                        if(initializer && !isEqualSign) {\n                            // throw new Error(\"Expected `=` before initializer\");\n                            throw {\n                                msg: \"Expected `=` before initializer\",\n                                span: initializer.span,\n                            } as ParseError\n                        }\n\n                        // `=` without initializer\n                        if(!initializer && isEqualSign) {\n                            throw {\n                                msg: \"Expected initializer after `=`\",\n                                span: equalSignSpan,\n                            } as ParseError\n                        }\n\n                        // if no :type and not =expr so reject\n                        if(!type && !initializer) {\n                            throw {\n                                msg: `Expected type or initializer after ${kind === 'Parameter' ? 'parameter' : kind === 'StructField' ? 'field' : 'variable'} name`,\n                                span: ident.span,\n                            } as ParseError\n                        }\n\n                    // ══════════ Build AST ══════════\n\n                        const field = AST.FieldNode.create(data.span,\n                            {\n                                kind: isPublic ? 'Public' : isStatic ? 'Static' : 'Private',\n                                span: visibilitySpan,\n                            },\n                            {\n                                kind: isComptime ? 'Comptime' : 'Runtime',\n                                span: comptimeSpan,\n                            },\n                            {\n                                kind: isMutable ? 'Mutable' : 'Immutable',\n                                span: mutSpan,\n                            },\n                            ident!,\n                            type,\n                            initializer\n                        );\n\n                        if(kind === 'StructField') {\n                            return ParserLib.Result.createAsCustom('passed', 'field-node', field, data.span);\n                        } else if(kind === 'Parameter') {\n                            return ParserLib.Result.createAsCustom('passed', 'param-node', field, data.span);\n                        } else {\n                            return ParserLib.Result.createAsCustom('passed', 'let-stmt-node',\n                                AST.StmtNode.create('Let', data.span,\n                                    new AST.LetStmtNode(data.span, field)\n                                ),\n                                data.span\n                            )\n                        }\n                }\n            }\n        );\n    }\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝","// Type.ts\n//\n// Developed with ❤️ by Maysara.\n\n\n\n// ╔════════════════════════════════════════ PACK ════════════════════════════════════════╗\n\n    import * as ParserLib   from '@je-es/parser';\n    import * as AST         from '@je-es/ast';\n    import { ParseError }   from '@je-es/parser';\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝\n\n\n\n// ╔════════════════════════════════════════ INIT ════════════════════════════════════════╗\n\n    export const Type: ParserLib.Rules = [\n\n        // TODO: There are some rules that need to be updated to work with the new style.\n\n        // ════════════ ROOT ════════════\n\n            ParserLib.createRule('Type',\n                ParserLib.rule('UnionType'),\n                {\n                    build: (data: ParserLib.Result) => data,\n                    errors: [ParserLib.error(() => true, \"Expected type\")]\n                }\n            ),\n\n        // ════════════ ---- ════════════\n\n            ParserLib.createRule('UnionType',\n                ParserLib.seq(\n                    ParserLib.rule('BaseType'),\n                    ParserLib.zeroOrMore(\n                        ParserLib.seq(\n                            ParserLib.token('|'),\n                            ParserLib.rule('BaseType')\n                        )\n                    )\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        const seq_array = data.getSequenceResult()!;\n                        const first = seq_array[0];\n                        const rest = seq_array[1].getRepeatResult()!;\n\n                        if (rest.length === 0) {\n                            return first;\n                        }\n\n                        const types: AST.TypeNode[] = [first.getCustomData()! as AST.TypeNode];\n\n                        for (const item of rest) {\n                            const seq = item.getSequenceResult()!;\n                            types.push(seq[1].getCustomData()! as AST.TypeNode);\n                        }\n\n                        const result = AST.TypeNode.asUnion(data.span, types);\n                        return ParserLib.Result.createAsCustom('passed', 'union-type', result, data.span);\n                    }\n                }\n            ),\n\n        // ════════════ ---- ════════════\n\n            ParserLib.createRule('BaseType',\n                ParserLib.choice(\n                    ParserLib.rule('FunctionType'),\n                    ParserLib.rule('ErrsetType'),\n                    ParserLib.rule('StructType'),\n                    ParserLib.rule('EnumType'),\n                    ParserLib.rule('TupleType'),\n                    ParserLib.rule('ArrayType'),\n                    ParserLib.rule('PointerType'),\n                    ParserLib.rule('OptionalType'),\n                    ParserLib.rule('PrimitiveType'),\n                    ParserLib.rule('IdentifierType'),\n                    ParserLib.rule('ParenType'),\n                ),\n                {\n                    build: (data: ParserLib.Result) => ParserLib.Result.createAsCustom('passed', 'base-type', data.getChoiceResult()!.getCustomData()!, data.span)\n                }\n            ),\n\n        // ════════════ ---- ════════════\n\n            ParserLib.createRule('StructType',\n                ParserLib.seq(\n                    // struct <CatchPoint>\n                    ParserLib.token('struct'),\n                    // {\n                    ParserLib.optional(ParserLib.token('{')),\n                    // members\n                    ParserLib.zeroOrMore( ParserLib.rule('StructMember') ),\n                    // }\n                    ParserLib.optional(ParserLib.token('}'))\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n\n                        // ══════════ Extract Data ════════\n\n                            const seq_array         = data.getSequenceResult()!;\n\n                            const isOpeningParen    = seq_array[1].isOptionalPassed();\n                            const isClosingParen    = seq_array[3].isOptionalPassed();\n\n                            const structSpan        = seq_array[0].getTokenSpan()!;\n                            const openingParenSpan  = isOpeningParen ? seq_array[1].getOptionalResult()!.getTokenSpan()! : null;\n                            const closingParenSpan  = isClosingParen ? seq_array[3].getOptionalResult()!.getTokenSpan()! : null;\n\n\n                            const membersCount  = seq_array[2].getRepeatCount()!;\n                            const members       = membersCount > 0\n                                                ? seq_array[2].getRepeatResult()!.map(member => member.getCustomData()! as AST.StructMemberNode)\n                                                : [];\n\n                        // ══════ Syntax validation ══════\n\n                            // Missing `{`\n                            if(!isOpeningParen) {\n                                throw {\n                                    msg: \"Expected '{' to begin struct body\",\n                                    span: {\n                                        start: structSpan.end,\n                                        end: structSpan.end + 1,\n                                    },\n                                } as ParseError;\n                            }\n\n                            // Missing `}`\n                            if(!isClosingParen) {\n                                throw {\n                                    msg: \"Expected '}' after struct body\",\n                                    span: {\n                                        start: closingParenSpan?.end ?? (membersCount > 0 && members![membersCount-1])\n                                                                        ? members![membersCount-1].span.end\n                                                                        : openingParenSpan?.end,\n                                        end: closingParenSpan?.end ?? (membersCount > 0 && members![membersCount-1])\n                                                                        ? members![membersCount-1].span.end+1\n                                                                        : openingParenSpan!.end+1\n                                    },\n                                } as ParseError;\n                            }\n\n                        // ══════════ Build AST ══════════\n\n                            const result = AST.TypeNode.asStruct(data.span, members);\n                            return ParserLib.Result.createAsCustom('passed', 'struct-type', result, data.span);\n                    },\n                }\n            ),\n\n            ParserLib.createRule('StructMember',\n                ParserLib.seq(\n                    ParserLib.choice(\n                        ParserLib.rule('StructField'),\n                        ParserLib.rule('FnStmt'),\n                    ),\n                    ParserLib.optional(ParserLib.token(';'))\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n\n                        // ══════════ Extract Data ════════\n\n                            const seq_array = data.getSequenceResult()!;\n                            const member = seq_array[0].getChoiceResult()!.getCustomData()! as AST.StmtNode | AST.FieldNode;\n\n                        // ══════ Syntax validation ══════\n\n                            // Missing member\n                            if(!member) {\n                                throw {\n                                    msg: \"Expected valid member\",\n                                    span: data.span,\n                                } as ParseError;\n                            }\n\n                        // ══════════ Build AST ══════════\n\n                            const result = member.kind === 'Func' // function stmt\n                                        ? AST.StructMemberNode.createMethod(member.span, (member as AST.StmtNode).getFunc()!)\n                                        : AST.StructMemberNode.createField(member.span, member as AST.FieldNode)\n\n                            return ParserLib.Result.createAsCustom('passed', 'struct-member', result, data.span);\n                    }\n                }\n            ),\n\n        // ════════════ ---- ════════════\n\n            ParserLib.createRule('EnumType',\n                ParserLib.seq(\n                    // enum <CatchPoint>\n                    ParserLib.token('enum'),\n                    // {\n                    ParserLib.optional(ParserLib.token('{')),\n                    // members\n                    ParserLib.zeroOrMore( ParserLib.rule('EnumVariant'), ParserLib.token(',') ),\n                    // }\n                    ParserLib.optional(ParserLib.token('}'))\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n\n                        // ══════════ Extract Data ════════\n\n                            const seq_array         = data.getSequenceResult()!;\n\n                            const isOpeningParen    = seq_array[1].isOptionalPassed();\n                            const isClosingParen    = seq_array[3].isOptionalPassed();\n\n                            const enumSpan          = seq_array[0].getTokenSpan()!;\n                            const openingParenSpan  = isOpeningParen ? seq_array[1].getOptionalResult()!.getTokenSpan()! : null;\n                            const closingParenSpan  = isClosingParen ? seq_array[3].getOptionalResult()!.getTokenSpan()! : null;\n\n\n                            const variantsCount     = seq_array[2].getRepeatCount()!;\n                            const variants          = variantsCount > 0\n                                                    ? seq_array[2].getRepeatResult()!.map(member => member.getCustomData()! as AST.EnumVariantNode)\n                                                    : [];\n\n                        // ══════ Syntax validation ══════\n\n                            // Missing `{`\n                            if(!isOpeningParen) {\n                                throw {\n                                    msg: \"Expected '{' after `enum` keyword\",\n                                    span: {\n                                        start: enumSpan.end,\n                                        end: enumSpan.end + 1,\n                                    },\n                                } as ParseError;\n                            }\n\n                            // Missing `}`\n                            if(!isClosingParen) {\n                                throw {\n                                    msg: \"Expected '}' after enum body\",\n                                    span: {\n                                        start: closingParenSpan?.end ?? variantsCount > 0\n                                                                        ? variants![variantsCount-1].span.end\n                                                                        : openingParenSpan?.end,\n                                        end: closingParenSpan?.end ?? variantsCount > 0\n                                                                        ? variants![variantsCount-1].span.end+1\n                                                                        : openingParenSpan!.end+1\n                                    },\n                                } as ParseError;\n                            }\n\n                        // ══════════ Build AST ══════════\n\n                            const result = AST.TypeNode.asEnum(data.span, variants);\n                            return ParserLib.Result.createAsCustom('passed', 'enum-type', result, data.span);\n                    },\n                }\n            ),\n\n            ParserLib.createRule('EnumVariant',\n                ParserLib.seq(\n                    // ident <CatchPoint>\n                    ParserLib.rule('Ident'),\n                    // :\n                    ParserLib.optional(ParserLib.token(`:`)),\n                    // type\n                    ParserLib.optional(ParserLib.rule('BaseType')),\n                ),\n                {\n                    build: (data: ParserLib.Result, parser: ParserLib.Parser) => {\n\n                        // ══════════ Extract Data ════════\n\n                            const seq_array         = data.getSequenceResult()!;\n                            const ident             = seq_array[0].getCustomData()! as AST.IdentNode;\n\n                            // () | {}\n                            const isColonSign       = seq_array[1].isOptionalPassed();\n                            const isColonSignSpan   = isColonSign ? seq_array[1].getOptionalResult()!.getTokenSpan()! : undefined;\n\n                            // Type\n                            const isType            = seq_array[2].isOptionalPassed()\n                            const type              = isType\n                                                        ? seq_array[2].getOptionalResult()!.getCustomData()! as AST.TypeNode\n                                                        : undefined;\n\n                        // ══════ Syntax validation ══════\n\n                            // type without `:`\n                                if(type && !isColonSign) {\n                                    // throw new Error(\"Expected `:` before type\");\n                                    throw {\n                                        msg: \"Expected `:` before type\",\n                                        span: type.span,\n                                    } as ParseError\n                                }\n\n                                // `:` without type\n                                if(!type && isColonSign) {\n                                    throw {\n                                        msg: \"Expected type after `:`\",\n                                        span: isColonSignSpan,\n                                    } as ParseError\n                                }\n\n                                // TODO: not allowed types...\n\n                        // ══════════ Build AST ══════════\n\n                            const variantNode = AST.EnumVariantNode.create(data.span, ident, type);\n                            return ParserLib.Result.createAsCustom('passed', 'enum-variant', variantNode, data.span);\n                    }\n                }\n            ),\n\n        // ════════════ ---- ════════════\n\n            ParserLib.createRule('FunctionType',\n                ParserLib.seq(\n                    // fn <CatchPoint>\n                    ParserLib.token('fn'),\n                    // (\n                    ParserLib.optional(ParserLib.token('(')),\n                    // parameters\n                    ParserLib.optional(\n                        ParserLib.oneOrMore(\n                            ParserLib.rule('Type'),\n                            ParserLib.token(','),\n                        ),\n                    ),\n                    // )\n                    ParserLib.optional(ParserLib.token(')')),\n                    // ->\n                    ParserLib.optional(ParserLib.token('->')),\n                    // error type\n                    ParserLib.optional(ParserLib.rule('Type')),\n                    // !\n                    ParserLib.optional(ParserLib.token('!')),\n                    // return type\n                    ParserLib.optional(ParserLib.rule('Type')),\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n\n                        // ══════════ Extract Data ════════\n\n                            const seq_array         = data.getSequenceResult()!;\n\n                            const isOpeningParen    = seq_array[1].isOptionalPassed();\n                            const isParams          = seq_array[2].isOptionalPassed();\n                            const isClosingParen    = seq_array[3].isOptionalPassed();\n                            const isArrowSign       = seq_array[4].isOptionalPassed();\n                            const isErrsetType       = seq_array[5].isOptionalPassed();\n                            const isNotSign         = seq_array[6].isOptionalPassed();\n                            const isReturnType      = seq_array[7].isOptionalPassed();\n\n                            const fnSpan            = seq_array[0].getTokenSpan()!;\n                            const openingParenSpan  = isOpeningParen ? seq_array[1].span : undefined;\n                            const closingParenSpan  = isClosingParen ? seq_array[3].span : undefined;\n                            const arrowSignSpan     = isArrowSign    ? seq_array[4].span : undefined;\n                            const notSignSpan       = isNotSign      ? seq_array[6].span : undefined;\n\n                            let parameters  = [] as AST.TypeNode[];\n                            let errorType   = isErrsetType   ? seq_array[5].getOptionalResult()!.getCustomData()! as AST.TypeNode   : undefined;\n                            let returnType  = isReturnType  ? seq_array[7].getOptionalResult()!.getCustomData()! as AST.TypeNode   : undefined;\n\n                            if (isParams) {\n                                const paramList = seq_array[2].getOptionalResult()!.getRepeatResult()!;\n                                parameters = paramList.map(r => r.getCustomData()! as AST.TypeNode);\n                            }\n\n                            // if we have an error type, but no return type and no not sign, then the error type is the return type\n                            if(errorType && !returnType && !isNotSign) {\n                                // if the error type is not an error type or an ident, then it is the return type\n                                if(!errorType!.isErrset() && !isNotSign) {\n                                    returnType = errorType;\n                                    errorType = undefined;\n                                }\n                            }\n\n                            // default error type\n                            if(isNotSign && !errorType) {\n                                errorType = AST.TypeNode.asErr();\n                            }\n\n                            let lastElemSpan = data.span;\n                            {\n                                if(returnType) {\n                                    lastElemSpan = returnType.span;\n                                } else if(isNotSign) {\n                                    lastElemSpan = notSignSpan!;\n                                } else if(errorType) {\n                                    lastElemSpan = errorType.span;\n                                } else if(isArrowSign) {\n                                    lastElemSpan = arrowSignSpan!;\n                                } else if(isClosingParen) {\n                                    lastElemSpan = closingParenSpan!;\n                                } else if(isParams && parameters.length) {\n                                    lastElemSpan = parameters[parameters.length-1].span;\n                                } else if(isOpeningParen) {\n                                    lastElemSpan = openingParenSpan!;\n                                } else {\n                                    lastElemSpan = fnSpan;\n                                }\n                            }\n\n                        // ══════ Syntax validation ══════\n\n                            // Missing opening parenthesis\n                            if (!isOpeningParen) {\n                                throw {\n                                    msg: \"Expected `(` after `fn` keyword for function type\",\n                                    span: fnSpan,\n                                } as ParseError;\n                            }\n\n                            // Missing closing parenthesis\n                            if (!isClosingParen) {\n                                throw {\n                                    msg: isParams && parameters.length\n                                            ? \"Expected `)` after parameters\"\n                                            : \"Expected parameters or `)` after `(`\",\n                                    span: isParams && parameters.length\n                                            ? { start: openingParenSpan!.start, end: parameters[parameters.length-1].span.end }\n                                            : openingParenSpan\n                                } as ParseError;\n                            }\n\n                            // Return type arrow without type\n                            if (isArrowSign && !returnType) {\n                                throw {\n                                    msg: \"Expected return type after `->`\",\n                                    span: arrowSignSpan,\n                                } as ParseError;\n                            }\n\n                            // Return type without arrow\n                            if (!isArrowSign && returnType) {\n                                throw {\n                                    msg: \"Expected `->` before return type\",\n                                    span: returnType.span,\n                                } as ParseError;\n                            }\n\n                            // Error type without `!`\n                            if (errorType && !isNotSign) {\n                                throw {\n                                    msg: \"Expected `!` after error type\",\n                                    span: errorType.span,\n                                } as ParseError;\n                            }\n\n                            // will never happend after this update.\n                            // // `!` without error type\n                            // if (!errorType && isNotSign) {\n                            //     throw {\n                            //         msg: \"Expected error type before `!`\",\n                            //         span: notSignSpan,\n                            //     } as ParseError;\n                            // }\n\n                            // Invalid Error type\n                            if(errorType && !errorType!.isErrset() && !errorType!.isErr() && !errorType!.isIdent()) {\n                                throw {\n                                    msg: \"Error type must be error name or error set\",\n                                    span: errorType!.span,\n                                } as ParseError;\n                            }\n\n                        // ══════════ Build AST ══════════\n\n                            const result = AST.TypeNode.asFunction(\n                                data.span,\n                                parameters,\n                                returnType,\n                                errorType,\n                            );\n\n                            return ParserLib.Result.createAsCustom('passed', 'function-type', result, data.span);\n                    },\n                    errors: [\n                        ParserLib.error(1, 'Expected `fn` keyword'),\n                    ]\n                }\n            ),\n\n        // ════════════ ---- ════════════\n\n            ParserLib.createRule('ErrsetType',\n                ParserLib.seq(\n                    // errset <CatchPoint>\n                    ParserLib.token('errset'),\n                    // {\n                    ParserLib.optional(ParserLib.token('{')),\n                    // names\n                    ParserLib.zeroOrMore(\n                        ParserLib.rule('Ident'),\n                        ParserLib.token(','),\n                    ),\n                    // }\n                    ParserLib.optional(ParserLib.token('}')),\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n\n                        // ══════════ Extract Data ════════\n\n                            const seq_array         = data.getSequenceResult()!;\n\n                            const isOpeningParen    = seq_array[1].isOptionalPassed();\n                            const isClosingParen    = seq_array[3].isOptionalPassed();\n\n                            const errorSpan         = seq_array[0].getTokenSpan()!;\n                            const openingParenSpan  = isOpeningParen ? seq_array[1].getOptionalResult()!.getTokenSpan()! : null;\n                            const closingParenSpan  = isClosingParen ? seq_array[3].getOptionalResult()!.getTokenSpan()! : null;\n\n                            const membersCount  = seq_array[2].getRepeatCount()!;\n                            const members       = membersCount > 0\n                                                ? seq_array[2].getRepeatResult()!.map(member => member.getCustomData()! as AST.IdentNode)\n                                                : undefined;\n\n                        // ══════ Syntax validation ══════\n\n                            // Missing `{`\n                            if(!isOpeningParen) {\n                                throw {\n                                    msg: \"Expected '{' after `errset` keyword\",\n                                    span: {\n                                        start: errorSpan.end,\n                                        end: errorSpan.end + 1,\n                                    },\n                                } as ParseError;\n                            }\n\n                            // no members\n                            if(!membersCount) {\n                                throw {\n                                    msg: \"Expected members after `{`\",\n                                    span: {\n                                        start: openingParenSpan?.start ?? errorSpan.start,\n                                        end: closingParenSpan?.end ?? openingParenSpan?.end ?? errorSpan.end,\n                                    },\n                                } as ParseError;\n                            }\n\n                            // Missing `}`\n                            if(!isClosingParen) {\n                                throw {\n                                    msg: \"Expected '}' after error set\",\n                                    span: {\n                                        start: closingParenSpan?.end ?? membersCount > 0\n                                                                        ? members![membersCount-1].span.end\n                                                                        : openingParenSpan?.end,\n                                        end: closingParenSpan?.end ?? membersCount > 0\n                                                                        ? members![membersCount-1].span.end+1\n                                                                        : openingParenSpan!.end+1\n                                    },\n                                } as ParseError;\n                            }\n\n                        // ══════════ Build AST ══════════\n\n                            const result = AST.TypeNode.asErrset(data.span, members!);\n                            return ParserLib.Result.createAsCustom('passed', 'error-type', result, data.span);\n                    },\n                }\n            ),\n\n        // ════════════ ---- ════════════\n\n            ParserLib.createRule('TupleType',\n                ParserLib.seq(\n                    ParserLib.token('.'),\n                    ParserLib.token('{'),\n                    ParserLib.zeroOrMore(\n                        ParserLib.rule('Type'),\n                        ParserLib.token(',')\n                    ),\n                    ParserLib.token('}')\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        const seq_array = data.getSequenceResult()!;\n                        const repeat_items = seq_array[2].getRepeatResult()!;\n                        const types: AST.TypeNode[] = [];\n\n                        for (const item of repeat_items) {\n                            types.push(item.getCustomData()! as AST.TypeNode);\n                        }\n\n                        // If only one type and no trailing comma, it's a parenthesized type, not a tuple\n                        if (types.length === 1) {\n                            return ParserLib.Result.createAsCustom('passed', 'paren-type', types[0], data.span);\n                        }\n\n                        const result = AST.TypeNode.asTuple(data.span, types);\n                        return ParserLib.Result.createAsCustom('passed', 'tuple-type', result, data.span);\n                    },\n\n                    errors: [\n                        ParserLib.error(0, \"Expected '.{' for tuple\"),\n                        ParserLib.error(2, \"Expected '}' for tuple\")\n                    ]\n                }\n            ),\n\n            ParserLib.createRule('OptionalType',\n                ParserLib.seq(\n                    ParserLib.token('?'),\n                    ParserLib.rule('BaseType')\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        const seq_array = data.getSequenceResult()!;\n                        const targetType = seq_array[1].getCustomData()! as AST.TypeNode;\n\n                        const result = AST.TypeNode.asOptional(data.span, targetType);\n                        return ParserLib.Result.createAsCustom('passed', 'optional-type', result, data.span);\n                    },\n\n                    errors: [\n                        ParserLib.error(0, \"Expected '?' for optional type\"),\n                        ParserLib.error(1, \"Expected target type for optional\")\n                    ]\n                }\n            ),\n\n            ParserLib.createRule('PointerType',\n                ParserLib.seq(\n                    ParserLib.token('*'),\n                    ParserLib.optional(ParserLib.token('mut')),\n                    ParserLib.rule('BaseType')\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        const seq_array = data.getSequenceResult()!;\n                        const mutable = seq_array[1].isOptionalPassed();\n                        const targetType = seq_array[2].getCustomData()! as AST.TypeNode;\n\n                        const result = AST.TypeNode.asPointer(data.span, targetType, mutable);\n                        return ParserLib.Result.createAsCustom('passed', 'pointer-type', result, data.span);\n                    },\n\n                    errors: [\n                        ParserLib.error(0, \"Expected '*' for pointer type\"),\n                        ParserLib.error(2, \"Expected target type for pointer\")\n                    ]\n                }\n            ),\n\n        // ════════════ ---- ════════════\n\n            ParserLib.createRule('PrimitiveType',\n                ParserLib.choice(\n                    // Basic types\n                    ParserLib.token('noreturn'),\n                    ParserLib.token('type'),\n                    ParserLib.token('void'),\n                    ParserLib.token('bool'),\n                    ParserLib.token('null_t'),\n                    ParserLib.token('und_t'),\n\n                    // Signed\n                    ParserLib.token('i_type'),\n                    ParserLib.token('isize'),\n\n                    // Unsigned\n                    ParserLib.token('u_type'),\n                    ParserLib.token('usize'),\n\n                    // Float\n                    ParserLib.token('f_type'),\n\n                    // ComptimeTypes\n                    ParserLib.token('cint'),\n                    ParserLib.token('cflt'),\n\n                    // Any\n                    ParserLib.token('any'),\n                    ParserLib.token('err'),\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        const selected = data.getChoiceResult()!;\n                        let type: AST.TypeNode;\n\n                        if (selected.isToken()) {\n                            const token = selected.getTokenData()!;\n                            switch (token.kind) {\n                                case 'noreturn':\n                                    type = AST.TypeNode.asNoreturn(token.span);\n                                    break;\n                                case 'type':\n                                    type = AST.TypeNode.asType(token.span);\n                                    break;\n                                case 'void':\n                                    type = AST.TypeNode.asVoid(token.span);\n                                    break;\n                                case 'bool':\n                                    type = AST.TypeNode.asBool(token.span);\n                                    break;\n                                case 'cint':\n                                    type = AST.TypeNode.asComptimeInt(token.span, token.value!);\n                                    break;\n                                case 'cflt':\n                                    type = AST.TypeNode.asComptimeFloat(token.span, token.value!);\n                                    break;\n                                case 'isize':\n                                    type = AST.TypeNode.asSigned(token.span, token.value!, 64);\n                                    break;\n                                case 'i_type':\n                                    type = AST.TypeNode.asSigned(token.span, token.value!, AST.PrimitiveTypeNode.calcWidth('i', token.value!));\n                                    break;\n                                case 'u_type':\n                                    type = AST.TypeNode.asUnsigned(token.span, token.value!, AST.PrimitiveTypeNode.calcWidth('u', token.value!));\n                                    break;\n                                case 'usize':\n                                    type = AST.TypeNode.asUnsigned(token.span, token.value!, 64);\n                                    break;\n                                case 'f_type':\n                                    type = AST.TypeNode.asFloat(token.span, token.value!, AST.PrimitiveTypeNode.calcWidth('f', token.value!));\n                                    break;\n                                case 'null_t':\n                                    type = AST.TypeNode.asNull(token.span);\n                                    break;\n                                case 'und_t':\n                                    type = AST.TypeNode.asUndefined(token.span);\n                                    break;\n                                case 'any':\n                                    type = AST.TypeNode.asAny(token.span);\n                                    break;\n                                case 'err':\n                                    type = AST.TypeNode.asErr(token.span);\n                                    break;\n                                default:\n                                    throw new Error(`Unknown primitive type: ${token.kind}`);\n                            }\n                        } else {\n                            // Custom rule result (SizedIntegerType or SizedFloatType)\n                            type = selected.getCustomData()! as AST.TypeNode;\n                        }\n\n                        return ParserLib.Result.createAsCustom('passed', 'primitive-type', type, data.span);\n                    },\n\n                    errors: [\n                        ParserLib.error(0, \"Expected primitive type\")\n                    ]\n                }\n            ),\n\n            ParserLib.createRule('IdentifierType',\n                ParserLib.token('ident'),\n                {\n                    build: (data: ParserLib.Result) => {\n                        const token = data.getTokenData()!;\n                        const type = AST.TypeNode.asIdentifier(token.span, token.value!);\n                        return ParserLib.Result.createAsCustom('passed', 'identifier-type', type, data.span);\n                    },\n\n                    errors: [\n                        ParserLib.error(0, \"Expected type identifier\")\n                    ]\n                }\n            ),\n\n            ParserLib.createRule('ArrayType',\n                ParserLib.seq(\n                    ParserLib.token('['),\n                    ParserLib.optional(ParserLib.rule('Expr')),\n                    ParserLib.token(']'),\n                    ParserLib.optional(ParserLib.token('mut')),\n                    ParserLib.rule('BaseType')\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        const seq_array = data.getSequenceResult()!;\n                        const size = seq_array[1].isOptionalPassed() ?\n                            seq_array[1].getOptionalResult()!.getCustomData()! as AST.ExprNode : undefined;\n                        const mutable = seq_array[3].isOptionalPassed();\n                        const elementType = seq_array[4].getCustomData()! as AST.TypeNode;\n\n                        const result = AST.TypeNode.asArray(data.span, elementType, size, mutable);\n                        return ParserLib.Result.createAsCustom('passed', 'array-type', result, data.span);\n                    },\n\n                    errors: [\n                        ParserLib.error(0, \"Expected '[' for array type\"),\n                        ParserLib.error(2, \"Expected ']' for array type\"),\n                        ParserLib.error(4, \"Expected element type for array\")\n                    ]\n                }\n            ),\n\n            ParserLib.createRule('ParenType',\n                ParserLib.seq(\n                    ParserLib.token('('),\n                    ParserLib.rule('Type'),\n                    ParserLib.token(')')\n                ),\n                {\n                    build: (data: ParserLib.Result) => {\n                        const seq_array = data.getSequenceResult()!;\n                        const parenType = AST.TypeNode.asParen(data.span, seq_array[1].getCustomData()! as AST.TypeNode);\n                        return ParserLib.Result.createAsCustom('passed', 'paren-type', parenType, data.span);\n                    },\n\n                    errors: [\n                        ParserLib.error(0, \"Expected '(' for parenthesized type\"),\n                        ParserLib.error(2, \"Expected ')' for parenthesized type\")\n                    ]\n                }\n            ),\n\n        // ════════════ ---- ════════════\n\n    ];\n\n// ╚══════════════════════════════════════════════════════════════════════════════════════╝"],"mappings":"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","names":["ParserLib","AST","seq","token","ParserLib","AST","ParserLib","AST","seq","token"]}